!<arch>
__.PKGDEF       0           0     0     644     61531     `
go object linux amd64 go1.6 X:none
build id "97238107d5a0639fa65f99a3102a0b33b8ce1f62"

$$
package openpgp
	import hash "hash"
	import io "io"
	import rsa "crypto/rsa"
	import crypto "crypto"
	import time "time"
	import armor "golang.org/x/crypto/openpgp/armor"
	import errors "golang.org/x/crypto/openpgp/errors"
	import strconv "strconv"
	import packet "golang.org/x/crypto/openpgp/packet"
	import s2k "golang.org/x/crypto/openpgp/s2k"
	import sha256 "crypto/sha256"
	type @"hash".Hash interface { BlockSize() (? int); Reset(); Size() (? int); Sum(@"hash".b []byte) (? []byte); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	func @"".NewCanonicalTextHash (@"".h·2 @"hash".Hash) (? @"hash".Hash) { return (&@"".canonicalTextHash{ @"".h:@"".h·2, @"".s:int(0x0) }) }
	var @"".PublicKeyType string
	var @"".PrivateKeyType string
	type @"time".zone struct { @"time".name string; @"time".offset int; @"time".isDST bool }
	type @"time".zoneTrans struct { @"time".when int64; @"time".index uint8; @"time".isstd bool; @"time".isutc bool }
	type @"time".Location struct { @"time".name string; @"time".zone []@"time".zone; @"time".tx []@"time".zoneTrans; @"time".cacheStart int64; @"time".cacheEnd int64; @"time".cacheZone *@"time".zone }
	func (@"time".l·2 *@"time".Location "esc:0x22") String () (? string)
	func (@"time".l·2 *@"time".Location "esc:0x1") @"time".firstZoneUsed () (? bool)
	func (@"time".l·2 *@"time".Location "esc:0x12") @"time".get () (? *@"time".Location)
	func (@"time".l·6 *@"time".Location "esc:0x32") @"time".lookup (@"time".sec·7 int64) (@"time".name·1 string, @"time".offset·2 int, @"time".isDST·3 bool, @"time".start·4 int64, @"time".end·5 int64)
	func (@"time".l·2 *@"time".Location "esc:0x1") @"time".lookupFirstZone () (? int)
	func (@"time".l·4 *@"time".Location "esc:0x1") @"time".lookupName (@"time".name·5 string "esc:0x1", @"time".unix·6 int64) (@"time".offset·1 int, @"time".isDST·2 bool, @"time".ok·3 bool)
	type @"time".Duration int64
	func (@"time".d·2 @"time".Duration) Hours () (? float64) { var @"time".hour·3 @"time".Duration; ; @"time".hour·3 = @"time".d·2 / @"time".Duration(0x34630b8a000); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0x34630b8a000); return float64(@"time".hour·3) + float64(@"time".nsec·4) * float64(8190022623310637111963488201822504381538623676021880892417778544696899264837610290203272971060556344039023584360473938041055625214280336402169897364226048p-553) }
	func (@"time".d·2 @"time".Duration) Minutes () (? float64) { var @"time".min·3 @"time".Duration; ; @"time".min·3 = @"time".d·2 / @"time".Duration(0xdf8475800); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0xdf8475800); return float64(@"time".min·3) + float64(@"time".nsec·4) * float64(7678146209353722106395056769533233877065564876941352542109479049699919628723768656821910653339403201031675627614471533358284117434246264392176261853609984p-547) }
	func (@"time".d·2 @"time".Duration) Nanoseconds () (? int64) { return int64(@"time".d·2) }
	func (@"time".d·2 @"time".Duration) Seconds () (? float64) { var @"time".sec·3 @"time".Duration; ; @"time".sec·3 = @"time".d·2 / @"time".Duration(0x3b9aca00); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0x3b9aca00); return float64(@"time".sec·3) + float64(@"time".nsec·4) * float64(7198262071269114660816079141112770740375861891461678802759824945047098083990024106014198994535558872472104883612039846078596891298747423852523262413111296p-541) }
	func (@"time".d·2 @"time".Duration) String () (? string)
	type @"time".Month int
	func (@"time".m·2 @"time".Month) String () (? string) { return @"time".months[@"time".m·2 - @"time".Month(0x1)] }
	type @"time".Weekday int
	func (@"time".d·2 @"time".Weekday) String () (? string) { return @"time".days[@"time".d·2] }
	type @"time".Time struct { @"time".sec int64; @"time".nsec int32; @"time".loc *@"time".Location }
	func (@"time".t·2 @"time".Time "esc:0x12") Add (@"time".d·3 @"time".Duration) (? @"time".Time) { @"time".t·2.@"time".sec += int64(@"time".d·3 / @"time".Duration(0x3b9aca00)); var @"time".nsec·4 int32; ; @"time".nsec·4 = int32(@"time".t·2.@"time".nsec) + int32(@"time".d·3 % @"time".Duration(0x3b9aca00)); if @"time".nsec·4 >= int32(0x3b9aca00) { @"time".t·2.@"time".sec++; @"time".nsec·4 -= int32(0x3b9aca00) } else { if @"time".nsec·4 < int32(0x0) { @"time".t·2.@"time".sec--; @"time".nsec·4 += int32(0x3b9aca00) } }; @"time".t·2.@"time".nsec = @"time".nsec·4; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x12") AddDate (@"time".years·3 int, @"time".months·4 int, @"time".days·5 int) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") After (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec > @"time".u·3.@"time".sec || @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec > @"time".u·3.@"time".nsec }
	func (@"time".t·2 @"time".Time "esc:0x9") AppendFormat (@"time".b·3 []byte "esc:0x1a", @"time".layout·4 string "esc:0x9") (? []byte)
	func (@"time".t·2 @"time".Time "esc:0x1") Before (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec < @"time".u·3.@"time".sec || @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec < @"time".u·3.@"time".nsec }
	func (@"time".t·4 @"time".Time "esc:0x1") Clock () (@"time".hour·1 int, @"time".min·2 int, @"time".sec·3 int)
	func (@"time".t·4 @"time".Time "esc:0x1") Date () (@"time".year·1 int, @"time".month·2 @"time".Month, @"time".day·3 int)
	func (@"time".t·2 @"time".Time "esc:0x1") Day () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") Equal (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec == @"time".u·3.@"time".nsec }
	func (@"time".t·2 @"time".Time "esc:0x9") Format (@"time".layout·3 string "esc:0x9") (? string)
	func (@"time".t·2 *@"time".Time "esc:0x1") GobDecode (@"time".data·3 []byte "esc:0x1") (? error)
	func (@"time".t·3 @"time".Time "esc:0x1") GobEncode () (? []byte, ? error)
	func (@"time".t·2 @"time".Time "esc:0x1") Hour () (? int)
	func (@"time".t·3 @"time".Time "esc:0x1") ISOWeek () (@"time".year·1 int, @"time".week·2 int)
	func (@"time".t·2 @"time".Time "esc:0x12") In (@"time".loc·3 *@"time".Location "esc:0x12") (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") IsZero () (? bool) { return @"time".t·2.@"time".sec == int64(0x0) && @"time".t·2.@"time".nsec == int32(0x0) }
	func (@"time".t·2 @"time".Time "esc:0x12") Local () (? @"time".Time) { @"time".t·2.@"time".loc = @"time".Local; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x12") Location () (? *@"time".Location) { var @"time".l·3 *@"time".Location; ; @"time".l·3 = @"time".t·2.@"time".loc; if @"time".l·3 == nil { @"time".l·3 = @"time".UTC }; return @"time".l·3 }
	func (@"time".t·3 @"time".Time "esc:0x1") MarshalBinary () (? []byte, ? error)
	func (@"time".t·3 @"time".Time "esc:0x9") MarshalJSON () (? []byte, ? error)
	func (@"time".t·3 @"time".Time "esc:0x9") MarshalText () (? []byte, ? error)
	func (@"time".t·2 @"time".Time "esc:0x1") Minute () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") Month () (? @"time".Month)
	func (@"time".t·2 @"time".Time "esc:0x1") Nanosecond () (? int) { return int(@"time".t·2.@"time".nsec) }
	func (@"time".t·2 @"time".Time "esc:0x12") Round (@"time".d·3 @"time".Duration) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") Second () (? int)
	func (@"time".t·2 @"time".Time "esc:0x9") String () (? string)
	func (@"time".t·2 @"time".Time "esc:0x1") Sub (@"time".u·3 @"time".Time "esc:0x1") (? @"time".Duration)
	func (@"time".t·2 @"time".Time "esc:0x12") Truncate (@"time".d·3 @"time".Duration) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x12") UTC () (? @"time".Time) { @"time".t·2.@"time".loc = @"time".UTC; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x1") Unix () (? int64) { return @"time".t·2.@"time".sec + int64(-0xe7791f700) }
	func (@"time".t·2 @"time".Time "esc:0x1") UnixNano () (? int64) { return (@"time".t·2.@"time".sec + int64(-0xe7791f700)) * int64(0x3b9aca00) + int64(@"time".t·2.@"time".nsec) }
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalBinary (@"time".data·3 []byte "esc:0x1") (? error)
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalJSON (@"time".data·3 []byte "esc:0x1") (@"time".err·1 error)
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalText (@"time".data·3 []byte "esc:0x1") (@"time".err·1 error)
	func (@"time".t·2 @"time".Time "esc:0x1") Weekday () (? @"time".Weekday)
	func (@"time".t·2 @"time".Time "esc:0x1") Year () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") YearDay () (? int)
	func (@"time".t·3 @"time".Time "esc:0x32") Zone () (@"time".name·1 string, @"time".offset·2 int)
	func (@"time".t·2 @"time".Time "esc:0x1") @"time".abs () (? uint64)
	func (@"time".t·5 @"time".Time "esc:0x1") @"time".date (@"time".full·6 bool) (@"time".year·1 int, @"time".month·2 @"time".Month, @"time".day·3 int, @"time".yday·4 int)
	func (@"time".t·4 @"time".Time "esc:0x32") @"time".locabs () (@"time".name·1 string, @"time".offset·2 int, @"time".abs·3 uint64)
	type @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm uint8
	func (@"golang.org/x/crypto/openpgp/packet".pka·2 @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm) CanEncrypt () (? bool)
	func (@"golang.org/x/crypto/openpgp/packet".pka·2 @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm) CanSign () (? bool)
	type @"golang.org/x/crypto/openpgp/packet".parsedMPI struct { @"golang.org/x/crypto/openpgp/packet".bytes []byte; @"golang.org/x/crypto/openpgp/packet".bitLength uint16 }
	import ecdsa "crypto/ecdsa" // indirect
	import elliptic "crypto/elliptic" // indirect
	import big "math/big" // indirect
	type @"math/big".Word uintptr
	type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
	import rand "math/rand" // indirect
	type @"math/rand".Source interface { Int63() (? int64); Seed(@"math/rand".seed int64) }
	type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") ExpFloat64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Float32 () (? float32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Float64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int () (? int)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int31 () (? int32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int31n (@"math/rand".n·3 int32) (? int32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int63 () (? int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int63n (@"math/rand".n·3 int64) (? int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Intn (@"math/rand".n·3 int) (? int)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") NormFloat64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Perm (@"math/rand".n·3 int) (? []int)
	func (@"math/rand".r·3 *@"math/rand".Rand "esc:0x9") Read (@"math/rand".p·4 []byte "esc:0x1") (@"math/rand".n·1 int, @"math/rand".err·2 error)
	func (@"math/rand".r·1 *@"math/rand".Rand "esc:0x9") Seed (@"math/rand".seed·2 int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Uint32 () (? uint32)
	type @"io".ByteScanner interface { ReadByte() (@"io".c byte, @"io".err error); UnreadByte() (? error) }
	type @"math/big".nat []@"math/big".Word
	func (@"math/big".z·2 @"math/big".nat) @"math/big".add (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".and (@"math/big".x·3 @"math/big".nat "esc:0x1", @"math/big".y·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".andNot (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".bit (@"math/big".i·3 uint) (? uint) { var @"math/big".j·4 uint; ; @"math/big".j·4 = @"math/big".i·3 / uint(0x40); if @"math/big".j·4 >= uint(len(@"math/big".x·2)) { return uint(0x0) }; return uint(@"math/big".x·2[@"math/big".j·4] >> (@"math/big".i·3 % uint(0x40)) & @"math/big".Word(0x1)) }
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".bitLen () (? int)
	func (@"math/big".z·2 @"math/big".nat "esc:0x1") @"math/big".bytes (@"math/big".buf·3 []byte "esc:0x1") (@"math/big".i·1 int)
	func (@"math/big".z·1 @"math/big".nat "esc:0x1") @"math/big".clear ()
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".cmp (@"math/big".y·3 @"math/big".nat "esc:0x1") (@"math/big".r·1 int)
	func (@"math/big".q·1 @"math/big".nat) @"math/big".convertWords (@"math/big".s·2 []byte "esc:0x1", @"math/big".b·3 @"math/big".Word, @"math/big".ndigits·4 int, @"math/big".bb·5 @"math/big".Word, @"math/big".table·6 []@"math/big".divisor "esc:0x9")
	func (@"math/big".z·3 @"math/big".nat) @"math/big".div (@"math/big".z2·4 @"math/big".nat, @"math/big".u·5 @"math/big".nat, @"math/big".v·6 @"math/big".nat) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".nat)
	func (@"math/big".z·3 @"math/big".nat "esc:0x12") @"math/big".divLarge (@"math/big".u·4 @"math/big".nat, @"math/big".uIn·5 @"math/big".nat, @"math/big".v·6 @"math/big".nat) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".nat)
	func (@"math/big".z·3 @"math/big".nat) @"math/big".divW (@"math/big".x·4 @"math/big".nat, @"math/big".y·5 @"math/big".Word) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".Word)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNN (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNNMontgomery (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNNWindowed (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expWW (@"math/big".x·3 @"math/big".Word, @"math/big".y·4 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x9") @"math/big".itoa (@"math/big".neg·3 bool, @"math/big".base·4 int) (? []byte)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".make (@"math/big".n·3 int) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat) @"math/big".modW (@"math/big".d·3 @"math/big".Word) (@"math/big".r·1 @"math/big".Word)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".montgomery (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat, @"math/big".k·6 @"math/big".Word, @"math/big".n·7 int) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mul (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mulAddWW (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".Word, @"math/big".r·5 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mulRange (@"math/big".a·3 uint64, @"math/big".b·4 uint64) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".norm () (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".or (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".n·2 @"math/big".nat) @"math/big".probablyPrime (@"math/big".reps·3 int) (? bool)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".random (@"math/big".rand·3 *@"math/rand".Rand "esc:0x9", @"math/big".limit·4 @"math/big".nat "esc:0x1", @"math/big".n·5 int) (? @"math/big".nat)
	func (@"math/big".z·5 @"math/big".nat) @"math/big".scan (@"math/big".r·6 @"io".ByteScanner, @"math/big".base·7 int, @"math/big".fracOk·8 bool) (@"math/big".res·1 @"math/big".nat, @"math/big".b·2 int, @"math/big".count·3 int, @"math/big".err·4 error)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".set (@"math/big".x·3 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setBit (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".i·4 uint, @"math/big".b·5 uint) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setBytes (@"math/big".buf·3 []byte "esc:0x1") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setUint64 (@"math/big".x·3 uint64) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setWord (@"math/big".x·3 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".shl (@"math/big".x·3 @"math/big".nat, @"math/big".s·4 uint) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".shr (@"math/big".x·3 @"math/big".nat, @"math/big".s·4 uint) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".sticky (@"math/big".i·3 uint) (? uint)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".sub (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".trailingZeroBits () (? uint)
	func (@"math/big".x·2 @"math/big".nat "esc:0x9") @"math/big".utoa (@"math/big".base·3 int) (? []byte)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".xor (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	import fmt "fmt" // indirect
	type @"fmt".State interface { Flag(@"fmt".c int) (? bool); Precision() (@"fmt".prec int, @"fmt".ok bool); Width() (@"fmt".wid int, @"fmt".ok bool); Write(@"fmt".b []byte) (@"fmt".ret int, @"fmt".err error) }
	type @"fmt".ScanState interface { Read(@"fmt".buf []byte) (@"fmt".n int, @"fmt".err error); ReadRune() (@"fmt".r rune, @"fmt".size int, @"fmt".err error); SkipSpace(); Token(@"fmt".skipSpace bool, @"fmt".f func(? rune) (? bool)) (@"fmt".token []byte, @"fmt".err error); UnreadRune() (? error); Width() (@"fmt".wid int, @"fmt".ok bool) }
	type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Abs (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Add (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") And (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") AndNot (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") Append (@"math/big".buf·3 []byte "esc:0x1a", @"math/big".base·4 int) (? []byte)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Binomial (@"math/big".n·3 int64, @"math/big".k·4 int64) (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") Bit (@"math/big".i·3 int) (? uint)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") BitLen () (? int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x22") Bits () (? []@"math/big".Word) { return @"math/big".x·2.@"math/big".abs }
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Bytes () (? []byte)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Cmp (@"math/big".y·3 *@"math/big".Int "esc:0x1") (@"math/big".r·1 int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Div (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") DivMod (@"math/big".x·4 *@"math/big".Int "esc:0x9", @"math/big".y·5 *@"math/big".Int "esc:0x9", @"math/big".m·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Exp (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x1", @"math/big".m·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·1 *@"math/big".Int "esc:0x9") Format (@"math/big".s·2 @"fmt".State, @"math/big".ch·3 rune)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") GCD (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9", @"math/big".a·5 *@"math/big".Int "esc:0x9", @"math/big".b·6 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") GobDecode (@"math/big".buf·3 []byte "esc:0x1") (? error)
	func (@"math/big".x·3 *@"math/big".Int "esc:0x1") GobEncode () (? []byte, ? error)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Int64 () (? int64) { var @"math/big".v·3 int64; ; @"math/big".v·3 = int64(@"math/big".low64(@"math/big".x·2.@"math/big".abs)); if @"math/big".x·2.@"math/big".neg { @"math/big".v·3 = -@"math/big".v·3 }; return @"math/big".v·3 }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Lsh (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 uint) (? *@"math/big".Int)
	func (@"math/big".x·3 *@"math/big".Int "esc:0x9") MarshalJSON () (? []byte, ? error)
	func (@"math/big".x·3 *@"math/big".Int "esc:0x9") MarshalText () (@"math/big".text·1 []byte, @"math/big".err·2 error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Mod (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") ModInverse (@"math/big".g·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") ModSqrt (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".p·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Mul (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") MulRange (@"math/big".a·3 int64, @"math/big".b·4 int64) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Neg (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Not (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Or (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") ProbablyPrime (@"math/big".n·3 int) (? bool)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Quo (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") QuoRem (@"math/big".x·4 *@"math/big".Int "esc:0x9", @"math/big".y·5 *@"math/big".Int "esc:0x9", @"math/big".r·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rand (@"math/big".rnd·3 *@"math/rand".Rand "esc:0x9", @"math/big".n·4 *@"math/big".Int "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rem (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rsh (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 uint) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") Scan (@"math/big".s·3 @"fmt".ScanState, @"math/big".ch·4 rune) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Set (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetBit (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".i·4 int, @"math/big".b·5 uint) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x12") SetBits (@"math/big".abs·3 []@"math/big".Word) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetBytes (@"math/big".buf·3 []byte "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetInt64 (@"math/big".x·3 int64) (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") SetString (@"math/big".s·4 string, @"math/big".base·5 int) (? *@"math/big".Int, ? bool)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetUint64 (@"math/big".x·3 uint64) (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Sign () (? int) { if len(@"math/big".x·2.@"math/big".abs) == int(0x0) { return int(0x0) }; if @"math/big".x·2.@"math/big".neg { return int(-0x1) }; return int(0x1) }
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") String () (? string)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Sub (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") Text (@"math/big".base·3 int) (? string)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Uint64 () (? uint64) { return @"math/big".low64(@"math/big".x·2.@"math/big".abs) }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") UnmarshalJSON (@"math/big".text·3 []byte) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") UnmarshalText (@"math/big".text·3 []byte) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Xor (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") @"math/big".binaryGCD (@"math/big".a·3 *@"math/big".Int "esc:0x9", @"math/big".b·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") @"math/big".modSqrt3Mod4Prime (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".p·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") @"math/big".modSqrtTonelliShanks (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".p·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".z·4 *@"math/big".Int "esc:0x1a") @"math/big".scan (@"math/big".r·5 @"io".ByteScanner, @"math/big".base·6 int) (? *@"math/big".Int, ? int, ? error)
	type @"crypto/elliptic".CurveParams struct { P *@"math/big".Int; N *@"math/big".Int; B *@"math/big".Int; Gx *@"math/big".Int; Gy *@"math/big".Int; BitSize int; Name string }
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") Add (@"crypto/elliptic".x1·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".x2·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y2·7 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") Double (@"crypto/elliptic".x1·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·2 *@"crypto/elliptic".CurveParams "esc:0x9") IsOnCurve (@"crypto/elliptic".x·3 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·4 *@"math/big".Int "esc:0x9") (? bool)
	func (@"crypto/elliptic".curve·2 *@"crypto/elliptic".CurveParams "esc:0x12") Params () (? *@"crypto/elliptic".CurveParams) { return @"crypto/elliptic".curve·2 }
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") ScalarBaseMult (@"crypto/elliptic".k·4 []byte "esc:0x1") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") ScalarMult (@"crypto/elliptic".Bx·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".By·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".k·6 []byte "esc:0x1") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·4 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".addJacobian (@"crypto/elliptic".x1·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z1·7 *@"math/big".Int "esc:0x9", @"crypto/elliptic".x2·8 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y2·9 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z2·10 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".affineFromJacobian (@"crypto/elliptic".x·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z·6 *@"math/big".Int "esc:0x9") (@"crypto/elliptic".xOut·1 *@"math/big".Int, @"crypto/elliptic".yOut·2 *@"math/big".Int)
	func (@"crypto/elliptic".curve·4 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".doubleJacobian (@"crypto/elliptic".x·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z·7 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	type @"crypto/elliptic".Curve interface { Add(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".x2 *@"math/big".Int, @"crypto/elliptic".y2 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); Double(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); IsOnCurve(@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) (? bool); Params() (? *@"crypto/elliptic".CurveParams); ScalarBaseMult(@"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); ScalarMult(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) }
	type @"crypto/ecdsa".PublicKey struct { ? @"crypto/elliptic".Curve; X *@"math/big".Int; Y *@"math/big".Int }
	type @"io".Reader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"io".Writer interface { Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"golang.org/x/crypto/openpgp/packet".ecdsaKey struct { @"golang.org/x/crypto/openpgp/packet".oid []byte; @"golang.org/x/crypto/openpgp/packet".p @"golang.org/x/crypto/openpgp/packet".parsedMPI }
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".byteLen () (? int) { return int(0x1) + len(@"golang.org/x/crypto/openpgp/packet".f·2.@"golang.org/x/crypto/openpgp/packet".oid) + int(0x2) + len(@"golang.org/x/crypto/openpgp/packet".f·2.@"golang.org/x/crypto/openpgp/packet".p.@"golang.org/x/crypto/openpgp/packet".bytes) }
	func (@"golang.org/x/crypto/openpgp/packet".f·3 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".newECDSA () (? *@"crypto/ecdsa".PublicKey, ? error)
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".kdfHashFunction uint8
	type @"golang.org/x/crypto/openpgp/packet".kdfAlgorithm uint8
	type @"golang.org/x/crypto/openpgp/packet".ecdhKdf struct { KdfHash @"golang.org/x/crypto/openpgp/packet".kdfHashFunction; KdfAlgo @"golang.org/x/crypto/openpgp/packet".kdfAlgorithm }
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdhKdf "esc:0x1") @"golang.org/x/crypto/openpgp/packet".byteLen () (? int) { return int(0x4) }
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdhKdf "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdhKdf "esc:0x1") @"golang.org/x/crypto/openpgp/packet".serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".SignatureType uint8
	type @"crypto".Hash uint
	func (@"crypto".h·2 @"crypto".Hash) Available () (? bool) { return @"crypto".h·2 < @"crypto".Hash(0x10) && @"crypto".hashes[@"crypto".h·2] != nil }
	func (@"crypto".h·2 @"crypto".Hash) HashFunc () (? @"crypto".Hash) { return @"crypto".h·2 }
	func (@"crypto".h·2 @"crypto".Hash) New () (? @"hash".Hash)
	func (@"crypto".h·2 @"crypto".Hash) Size () (? int)
	type @"golang.org/x/crypto/openpgp/packet".signatureSubpacketType uint8
	type @"golang.org/x/crypto/openpgp/packet".outputSubpacket struct { @"golang.org/x/crypto/openpgp/packet".hashed bool; @"golang.org/x/crypto/openpgp/packet".subpacketType @"golang.org/x/crypto/openpgp/packet".signatureSubpacketType; @"golang.org/x/crypto/openpgp/packet".isCritical bool; @"golang.org/x/crypto/openpgp/packet".contents []byte }
	import cipher "crypto/cipher" // indirect
	type @"crypto/cipher".Block interface { BlockSize() (? int); Decrypt(@"crypto/cipher".dst []byte, @"crypto/cipher".src []byte); Encrypt(@"crypto/cipher".dst []byte, @"crypto/cipher".src []byte) }
	type @"golang.org/x/crypto/openpgp/packet".CipherFunction uint8
	func (@"golang.org/x/crypto/openpgp/packet".cipher·2 @"golang.org/x/crypto/openpgp/packet".CipherFunction) KeySize () (? int)
	func (@"golang.org/x/crypto/openpgp/packet".cipher·2 @"golang.org/x/crypto/openpgp/packet".CipherFunction) @"golang.org/x/crypto/openpgp/packet".blockSize () (? int)
	func (@"golang.org/x/crypto/openpgp/packet".cipher·2 @"golang.org/x/crypto/openpgp/packet".CipherFunction) @"golang.org/x/crypto/openpgp/packet".new (@"golang.org/x/crypto/openpgp/packet".key·3 []byte) (@"golang.org/x/crypto/openpgp/packet".block·1 @"crypto/cipher".Block)
	type @"golang.org/x/crypto/openpgp/packet".PrivateKey struct { ? @"golang.org/x/crypto/openpgp/packet".PublicKey; Encrypted bool; @"golang.org/x/crypto/openpgp/packet".encryptedData []byte; @"golang.org/x/crypto/openpgp/packet".cipher @"golang.org/x/crypto/openpgp/packet".CipherFunction; @"golang.org/x/crypto/openpgp/packet".s2k func(@"golang.org/x/crypto/openpgp/packet".out []byte, @"golang.org/x/crypto/openpgp/packet".in []byte); PrivateKey interface {}; @"golang.org/x/crypto/openpgp/packet".sha1Checksum bool; @"golang.org/x/crypto/openpgp/packet".iv []byte }
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") Decrypt (@"golang.org/x/crypto/openpgp/packet".passphrase·3 []byte) (? error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parseDSAPrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parseElGamalPrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parsePrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parseRSAPrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".CompressionAlgo uint8
	type @"golang.org/x/crypto/openpgp/packet".CompressionConfig struct { Level int }
	type @"golang.org/x/crypto/openpgp/packet".Config struct { Rand @"io".Reader; DefaultHash @"crypto".Hash; DefaultCipher @"golang.org/x/crypto/openpgp/packet".CipherFunction; Time func() (? @"time".Time); DefaultCompressionAlgo @"golang.org/x/crypto/openpgp/packet".CompressionAlgo; CompressionConfig *@"golang.org/x/crypto/openpgp/packet".CompressionConfig; S2KCount int; RSABits int }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") Cipher () (? @"golang.org/x/crypto/openpgp/packet".CipherFunction) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || uint8(@"golang.org/x/crypto/openpgp/packet".c·2.DefaultCipher) == uint8(0x0) { return @"golang.org/x/crypto/openpgp/packet".CipherFunction(0x7) }; return @"golang.org/x/crypto/openpgp/packet".c·2.DefaultCipher }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") Compression () (? @"golang.org/x/crypto/openpgp/packet".CompressionAlgo) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil { return @"golang.org/x/crypto/openpgp/packet".CompressionAlgo(0x0) }; return @"golang.org/x/crypto/openpgp/packet".c·2.DefaultCompressionAlgo }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") Hash () (? @"crypto".Hash) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || uint(@"golang.org/x/crypto/openpgp/packet".c·2.DefaultHash) == uint(0x0) { return @"crypto".Hash(0x5) }; return @"golang.org/x/crypto/openpgp/packet".c·2.DefaultHash }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") Now () (? @"time".Time)
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") PasswordHashIterations () (? int) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || @"golang.org/x/crypto/openpgp/packet".c·2.S2KCount == int(0x0) { return int(0x0) }; return @"golang.org/x/crypto/openpgp/packet".c·2.S2KCount }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x22") Random () (? @"io".Reader) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || @"golang.org/x/crypto/openpgp/packet".c·2.Rand == nil { return @"crypto/rand".Reader }; return @"golang.org/x/crypto/openpgp/packet".c·2.Rand }
	type @"golang.org/x/crypto/openpgp/packet".Signature struct { SigType @"golang.org/x/crypto/openpgp/packet".SignatureType; PubKeyAlgo @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm; Hash @"crypto".Hash; HashSuffix []byte; HashTag [2]byte; CreationTime @"time".Time; RSASignature @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigR @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigS @"golang.org/x/crypto/openpgp/packet".parsedMPI; ECDSASigR @"golang.org/x/crypto/openpgp/packet".parsedMPI; ECDSASigS @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".rawSubpackets []@"golang.org/x/crypto/openpgp/packet".outputSubpacket; SigLifetimeSecs *uint32; KeyLifetimeSecs *uint32; PreferredSymmetric []uint8; PreferredHash []uint8; PreferredCompression []uint8; IssuerKeyId *uint64; IsPrimaryId *bool; FlagsValid bool; FlagCertify bool; FlagSign bool; FlagEncryptCommunications bool; FlagEncryptStorage bool; RevocationReason *uint8; RevocationReasonText string; MDC bool; EmbeddedSignature *@"golang.org/x/crypto/openpgp/packet".Signature; @"golang.org/x/crypto/openpgp/packet".outSubpackets []@"golang.org/x/crypto/openpgp/packet".outputSubpacket }
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x1") KeyExpired (@"golang.org/x/crypto/openpgp/packet".currentTime·3 @"time".Time "esc:0x1") (? bool) { if @"golang.org/x/crypto/openpgp/packet".sig·2.KeyLifetimeSecs == nil { return bool(false) }; var @"golang.org/x/crypto/openpgp/packet".expiry·4 @"time".Time; ; @"golang.org/x/crypto/openpgp/packet".expiry·4 = @"golang.org/x/crypto/openpgp/packet".sig·2.CreationTime.Add(@"time".Duration(*@"golang.org/x/crypto/openpgp/packet".sig·2.KeyLifetimeSecs) * @"time".Duration(0x3b9aca00)); return @"golang.org/x/crypto/openpgp/packet".currentTime·3.After(@"golang.org/x/crypto/openpgp/packet".expiry·4) }
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature) Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") Sign (@"golang.org/x/crypto/openpgp/packet".h·3 @"hash".Hash, @"golang.org/x/crypto/openpgp/packet".priv·4 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") SignKey (@"golang.org/x/crypto/openpgp/packet".pub·3 *@"golang.org/x/crypto/openpgp/packet".PublicKey, @"golang.org/x/crypto/openpgp/packet".priv·4 *@"golang.org/x/crypto/openpgp/packet".PrivateKey, @"golang.org/x/crypto/openpgp/packet".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") SignUserId (@"golang.org/x/crypto/openpgp/packet".id·3 string "esc:0x1", @"golang.org/x/crypto/openpgp/packet".pub·4 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".priv·5 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".config·6 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") @"golang.org/x/crypto/openpgp/packet".buildHashSuffix () (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") @"golang.org/x/crypto/openpgp/packet".buildSubpackets () (@"golang.org/x/crypto/openpgp/packet".subpackets·1 []@"golang.org/x/crypto/openpgp/packet".outputSubpacket)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature) @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·3 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") @"golang.org/x/crypto/openpgp/packet".signPrepareHash (@"golang.org/x/crypto/openpgp/packet".h·4 @"hash".Hash) (@"golang.org/x/crypto/openpgp/packet".digest·1 []byte, @"golang.org/x/crypto/openpgp/packet".err·2 error)
	type @"golang.org/x/crypto/openpgp/packet".SignatureV3 struct { SigType @"golang.org/x/crypto/openpgp/packet".SignatureType; CreationTime @"time".Time; IssuerKeyId uint64; PubKeyAlgo @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm; Hash @"crypto".Hash; HashTag [2]byte; RSASignature @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigR @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigS @"golang.org/x/crypto/openpgp/packet".parsedMPI }
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".SignatureV3 "esc:0x9") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".SignatureV3) @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".PublicKey struct { CreationTime @"time".Time; PubKeyAlgo @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm; PublicKey interface {}; Fingerprint [20]byte; KeyId uint64; IsSubkey bool; @"golang.org/x/crypto/openpgp/packet".n @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".e @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".p @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".q @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".g @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".y @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".ec *@"golang.org/x/crypto/openpgp/packet".ecdsaKey; @"golang.org/x/crypto/openpgp/packet".ecdh *@"golang.org/x/crypto/openpgp/packet".ecdhKdf }
	func (@"golang.org/x/crypto/openpgp/packet".pk·3 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") BitLength () (@"golang.org/x/crypto/openpgp/packet".bitLength·1 uint16, @"golang.org/x/crypto/openpgp/packet".err·2 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") CanSign () (? bool) { return @"golang.org/x/crypto/openpgp/packet".pk·2.PubKeyAlgo != @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm(0x2) && @"golang.org/x/crypto/openpgp/packet".pk·2.PubKeyAlgo != @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm(0x10) }
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) KeyIdShortString () (? string)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) KeyIdString () (? string)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·1 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") SerializeSignaturePrefix (@"golang.org/x/crypto/openpgp/packet".h·2 @"io".Writer)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) VerifyKeySignature (@"golang.org/x/crypto/openpgp/packet".signed·3 *@"golang.org/x/crypto/openpgp/packet".PublicKey, @"golang.org/x/crypto/openpgp/packet".sig·4 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (? error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) VerifyRevocationSignature (@"golang.org/x/crypto/openpgp/packet".sig·3 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifySignature (@"golang.org/x/crypto/openpgp/packet".signed·3 @"hash".Hash, @"golang.org/x/crypto/openpgp/packet".sig·4 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifySignatureV3 (@"golang.org/x/crypto/openpgp/packet".signed·3 @"hash".Hash, @"golang.org/x/crypto/openpgp/packet".sig·4 *@"golang.org/x/crypto/openpgp/packet".SignatureV3 "esc:0x1") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifyUserIdSignature (@"golang.org/x/crypto/openpgp/packet".id·3 string "esc:0x1", @"golang.org/x/crypto/openpgp/packet".pub·4 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".sig·5 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifyUserIdSignatureV3 (@"golang.org/x/crypto/openpgp/packet".id·3 string "esc:0x1", @"golang.org/x/crypto/openpgp/packet".pub·4 *@"golang.org/x/crypto/openpgp/packet".PublicKey, @"golang.org/x/crypto/openpgp/packet".sig·5 *@"golang.org/x/crypto/openpgp/packet".SignatureV3 "esc:0x1") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parseDSA (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parseElGamal (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parseRSA (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".serializeWithoutHeaders (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·1 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".setFingerPrintAndKeyId ()
	type @"golang.org/x/crypto/openpgp/packet".UserId struct { Id string; Name string; Comment string; Email string }
	func (@"golang.org/x/crypto/openpgp/packet".uid·2 *@"golang.org/x/crypto/openpgp/packet".UserId "esc:0x1") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (? error)
	func (@"golang.org/x/crypto/openpgp/packet".uid·2 *@"golang.org/x/crypto/openpgp/packet".UserId "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"".Identity struct { Name string; UserId *@"golang.org/x/crypto/openpgp/packet".UserId; SelfSignature *@"golang.org/x/crypto/openpgp/packet".Signature; Signatures []*@"golang.org/x/crypto/openpgp/packet".Signature }
	type @"".Subkey struct { PublicKey *@"golang.org/x/crypto/openpgp/packet".PublicKey; PrivateKey *@"golang.org/x/crypto/openpgp/packet".PrivateKey; Sig *@"golang.org/x/crypto/openpgp/packet".Signature }
	type @"".Key struct { Entity *@"".Entity; PublicKey *@"golang.org/x/crypto/openpgp/packet".PublicKey; PrivateKey *@"golang.org/x/crypto/openpgp/packet".PrivateKey; SelfSignature *@"golang.org/x/crypto/openpgp/packet".Signature }
	type @"".Entity struct { PrimaryKey *@"golang.org/x/crypto/openpgp/packet".PublicKey; PrivateKey *@"golang.org/x/crypto/openpgp/packet".PrivateKey; Identities map[string]*@"".Identity; Revocations []*@"golang.org/x/crypto/openpgp/packet".Signature; Subkeys []@"".Subkey }
	func (@"".e·2 *@"".Entity "esc:0x9") Serialize (@"".w·3 @"io".Writer) (? error)
	func (@"".e·2 *@"".Entity "esc:0x9") SerializePrivate (@"".w·3 @"io".Writer, @"".config·4 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".err·1 error)
	func (@"".e·2 *@"".Entity "esc:0x9") SignIdentity (@"".identity·3 string "esc:0x1", @"".signer·4 *@"".Entity, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func (@"".e·3 *@"".Entity "esc:0x12") @"".encryptionKey (@"".now·4 @"time".Time "esc:0x1") (? @"".Key, ? bool)
	func (@"".e·2 *@"".Entity "esc:0x32") @"".primaryIdentity () (? *@"".Identity)
	func (@"".e·3 *@"".Entity "esc:0x12") @"".signingKey (@"".now·4 @"time".Time "esc:0x1") (? @"".Key, ? bool)
	type @"".KeyRing interface { DecryptionKeys() (? []@"".Key); KeysById(@"".id uint64) (? []@"".Key); KeysByIdUsage(@"".id uint64, @"".requiredUsage byte) (? []@"".Key) }
	type @"".EntityList []*@"".Entity
	func (@"".el·2 @"".EntityList "esc:0x9") DecryptionKeys () (@"".keys·1 []@"".Key)
	func (@"".el·2 @"".EntityList "esc:0x9") KeysById (@"".id·3 uint64) (@"".keys·1 []@"".Key)
	func (@"".el·2 @"".EntityList "esc:0x9") KeysByIdUsage (@"".id·3 uint64, @"".requiredUsage·4 byte) (@"".keys·1 []@"".Key)
	func @"".ReadArmoredKeyRing (@"".r·3 @"io".Reader) (? @"".EntityList, ? error)
	func @"".ReadKeyRing (@"".r·3 @"io".Reader) (@"".el·1 @"".EntityList, @"".err·2 error)
	type @"golang.org/x/crypto/openpgp/packet".Packet interface { @"golang.org/x/crypto/openpgp/packet".parse(? @"io".Reader) (? error) }
	type @"golang.org/x/crypto/openpgp/packet".Reader struct { @"golang.org/x/crypto/openpgp/packet".q []@"golang.org/x/crypto/openpgp/packet".Packet; @"golang.org/x/crypto/openpgp/packet".readers []@"io".Reader }
	func (@"golang.org/x/crypto/openpgp/packet".r·3 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x3a") Next () (@"golang.org/x/crypto/openpgp/packet".p·1 @"golang.org/x/crypto/openpgp/packet".Packet, @"golang.org/x/crypto/openpgp/packet".err·2 error)
	func (@"golang.org/x/crypto/openpgp/packet".r·2 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x9") Push (@"golang.org/x/crypto/openpgp/packet".reader·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error) { if len(@"golang.org/x/crypto/openpgp/packet".r·2.@"golang.org/x/crypto/openpgp/packet".readers) >= int(0x20) { return @"golang.org/x/crypto/openpgp/errors".StructuralError(@"golang.org/x/crypto/openpgp/errors".StructuralError("too many layers of packets")) }; @"golang.org/x/crypto/openpgp/packet".r·2.@"golang.org/x/crypto/openpgp/packet".readers = append(@"golang.org/x/crypto/openpgp/packet".r·2.@"golang.org/x/crypto/openpgp/packet".readers, @"golang.org/x/crypto/openpgp/packet".reader·3); return nil }
	func (@"golang.org/x/crypto/openpgp/packet".r·1 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x9") Unread (@"golang.org/x/crypto/openpgp/packet".p·2 @"golang.org/x/crypto/openpgp/packet".Packet) { @"golang.org/x/crypto/openpgp/packet".r·1.@"golang.org/x/crypto/openpgp/packet".q = append(@"golang.org/x/crypto/openpgp/packet".r·1.@"golang.org/x/crypto/openpgp/packet".q, @"golang.org/x/crypto/openpgp/packet".p·2) }
	func @"".ReadEntity (@"".packets·3 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x9") (? *@"".Entity, ? error)
	func @"".NewEntity (@"".name·3 string, @"".comment·4 string, @"".email·5 string, @"".config·6 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? *@"".Entity, ? error)
	var @"".SignatureType string
	type @"golang.org/x/crypto/openpgp/packet".LiteralData struct { IsBinary bool; FileName string; Time uint32; Body @"io".Reader }
	func (@"golang.org/x/crypto/openpgp/packet".l·2 *@"golang.org/x/crypto/openpgp/packet".LiteralData "esc:0x1") ForEyesOnly () (? bool) { return @"golang.org/x/crypto/openpgp/packet".l·2.FileName == string("_CONSOLE") }
	func (@"golang.org/x/crypto/openpgp/packet".l·2 *@"golang.org/x/crypto/openpgp/packet".LiteralData "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"io".ReadCloser interface { Close() (? error); Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"".MessageDetails struct { IsEncrypted bool; EncryptedToKeyIds []uint64; IsSymmetricallyEncrypted bool; DecryptedWith @"".Key; IsSigned bool; SignedByKeyId uint64; SignedBy *@"".Key; LiteralData *@"golang.org/x/crypto/openpgp/packet".LiteralData; UnverifiedBody @"io".Reader; SignatureError error; Signature *@"golang.org/x/crypto/openpgp/packet".Signature; @"".decrypted @"io".ReadCloser }
	type @"".PromptFunction func(@"".keys []@"".Key, @"".symmetric bool) (? []byte, ? error)
	func @"".ReadMessage (@"".r·3 @"io".Reader, @"".keyring·4 @"".KeyRing, @"".prompt·5 @"".PromptFunction "esc:0x1", @"".config·6 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".md·1 *@"".MessageDetails, @"".err·2 error)
	func @"".CheckDetachedSignature (@"".keyring·3 @"".KeyRing, @"".signed·4 @"io".Reader, @"".signature·5 @"io".Reader) (@"".signer·1 *@"".Entity, @"".err·2 error)
	func @"".CheckArmoredDetachedSignature (@"".keyring·3 @"".KeyRing, @"".signed·4 @"io".Reader, @"".signature·5 @"io".Reader) (@"".signer·1 *@"".Entity, @"".err·2 error)
	func @"".DetachSign (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func @"".ArmoredDetachSign (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".err·1 error)
	func @"".DetachSignText (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func @"".ArmoredDetachSignText (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	type @"".FileHints struct { IsBinary bool; FileName string; ModTime @"time".Time }
	type @"io".WriteCloser interface { Close() (? error); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	func @"".SymmetricallyEncrypt (@"".ciphertext·3 @"io".Writer, @"".passphrase·4 []byte "esc:0x9", @"".hints·5 *@"".FileHints "esc:0x1", @"".config·6 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".plaintext·1 @"io".WriteCloser, @"".err·2 error)
	func @"".Encrypt (@"".ciphertext·3 @"io".Writer, @"".to·4 []*@"".Entity "esc:0x9", @"".signed·5 *@"".Entity "esc:0x12", @"".hints·6 *@"".FileHints "esc:0x1", @"".config·7 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1a") (@"".plaintext·1 @"io".WriteCloser, @"".err·2 error)
	func @"".init ()
	type @"".canonicalTextHash struct { @"".h @"hash".Hash; @"".s int }
	func (@"".cth·2 *@"".canonicalTextHash "esc:0x9") BlockSize () (? int)
	func (@"".cth·1 *@"".canonicalTextHash "esc:0x9") Reset ()
	func (@"".cth·2 *@"".canonicalTextHash "esc:0x9") Size () (? int)
	func (@"".cth·2 *@"".canonicalTextHash "esc:0x9") Sum (@"".in·3 []byte) (? []byte)
	func (@"".cth·3 *@"".canonicalTextHash "esc:0x9") Write (@"".buf·4 []byte) (? int, ? error)
	var @"time".months [12]string
	var @"time".days [7]string
	var @"time".Local *@"time".Location
	var @"time".UTC *@"time".Location
	func @"math/big".low64 (@"math/big".z·2 @"math/big".nat "esc:0x1") (? uint64) { if len(@"math/big".z·2) == int(0x0) { return uint64(0x0) }; var @"math/big".v·3 uint64; ; @"math/big".v·3 = uint64(@"math/big".z·2[int(0x0)]); if false && len(@"math/big".z·2) > int(0x1) { @"math/big".v·3 |= uint64(@"math/big".z·2[int(0x1)]) << uint(0x20) }; return @"math/big".v·3 }
	var @"crypto".hashes []func() (? @"hash".Hash)
	import rand "crypto/rand" // indirect
	var @"crypto/rand".Reader @"io".Reader
	type @"golang.org/x/crypto/openpgp/errors".StructuralError string
	func (@"golang.org/x/crypto/openpgp/errors".s·2 @"golang.org/x/crypto/openpgp/errors".StructuralError "esc:0x1") Error () (? string) { return string("openpgp: invalid data: ") + string(@"golang.org/x/crypto/openpgp/errors".s·2) }

$$
 _go_.o          0           0     0     644     272391    `
go object linux amd64 go1.6 X:none

!
  go13ldhash.acrypto/rsa.aio.atime.aFgolang.org/x/crypto/openpgp/armor.aHgolang.org/x/crypto/openpgp/errors.aHgolang.org/x/crypto/openpgp/packet.acrypto.acrypto/sha256.astrconv.aBgolang.org/x/crypto/openpgp/s2k.a ."".NewCanonicalTextHash    dH%    H;a   H(1H\$@H\$HH    H$    HD$HD$ Hl$0H(Hl$8=     ubHhH@    HD$ H    1H9tH\$ H\$HHD$@H(H    H$H    H\$H    H\$    HD$L@L$Hl$    HD$     (
      L  2type."".canonicalTextHash   ^  "runtime.newobject    (runtime.writeBarrier     Ngo.itab.*"".canonicalTextHash.hash.Hash     4type.*"".canonicalTextHash     type.hash.Hash     Ngo.itab.*"".canonicalTextHash.hash.Hash      runtime.typ2Itab     .runtime.writebarrierptr     0runtime.morestack_noctxt   @P  "".autotmp_0002 4type.*"".canonicalTextHash "".autotmp_0001  4type.*"".canonicalTextHash "".~r1  type.hash.Hash "".h  type.hash.Hash PnOPHO Wm "#4m  .{7 Tgclocals·aefd16b155593f6f07980a05b297ad1f Tgclocals·0c8aa8e80191a30eac23f1a218103f16   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go/home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/read.go:"".(*canonicalTextHash).Write  
  
dH%    HD$H;Ax  H   L$   L$   H$   1H$   H$   1H$   L$   1H$   HD$@L$   MHl$@H9}@LD$PA(H|$HHHiH      HA   IHHl$@H9|H$   MH9   H)I)MI tM1HHH tlH	HkL$   LL$H$   Ht$L$   LD$Hl$`H,$HL$XHY@H$   H$   1H$   H$   HĘ   É    
=HH|$8ML9   H9   H)I)MI tM1HHH    H	HkLL$hLL$H|$pH|$LD$xLD$Hl$`H,$HL$XHY@H$   H tnHHkH    H\$H    H\$H    H\$Hl$`H,$HL$XHY@L$   L$   LD$PH|$HH$   Ht$8HH뎉@    H,HA        f
               $runtime.panicslice            "".newline    "".newline     "".newline          	  $runtime.panicslice   
  0runtime.morestack_noctxt   p  "".autotmp_0011 type.*uint8 "".autotmp_0010 type.int "".autotmp_0009 type.int "".autotmp_0008  type.int "".autotmp_0007  type.[]uint8 "".autotmp_0006 _type.[]uint8 "".autotmp_0005 /type.[]uint8 "".i type.int "".~r2 Ptype.error "".~r1 @type.int "".buf type.[]uint8 "".cth  4type.*"".canonicalTextHash "  Z.IE
	u*	yo
  . Tgclocals·5cbd57cf8f9b35eac9551b20a42afe1f Tgclocals·fdec177485cbfa40ac91f85390ec1fea   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go6"".(*canonicalTextHash).Sum    dH%    H;a   HH1H\$pH\$xH$   H\$PH t_HHkH\$XH\$H\$`H\$H\$hH\$Hl$@H,$HL$8HY8HT$ HL$(HD$0HT$pHL$xH$   HHÉ    ]
               0runtime.morestack_noctxt   p  "".~r1 @type.[]uint8 
"".in type.[]uint8 "".cth  4type.*"".canonicalTextHash }  Z+n 
 mC Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go:"".(*canonicalTextHash).Reset    dH%    H;av@HH\$ H t-HHkHl$H,$HL$HY(H\$ HC    HÉ    
      n         0runtime.morestack_noctxt   0  "".cth  4type.*"".canonicalTextHash 07/0/ ` b& 
 7) Tgclocals·87d20ce1b58390b294df80b886db78bf Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go8"".(*canonicalTextHash).Size    dH%    H;av=H H\$(H t*HHkHl$H,$HL$HY0H\$H\$0H É    
      n         0runtime.morestack_noctxt    @  "".~r0 type.int "".cth  4type.*"".canonicalTextHash @4?@? ` l9 
 7) Tgclocals·3f5c1f818fa7055d0400cecd34057162 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.goB"".(*canonicalTextHash).BlockSize    dH%    H;av=H H\$(H t*HHkHl$H,$HL$HY H\$H\$0H É    
      n         0runtime.morestack_noctxt    @  "".~r0 type.int "".cth  4type.*"".canonicalTextHash @4?@? ` t9 
 7) Tgclocals·3f5c1f818fa7055d0400cecd34057162 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go8"".(*Entity).primaryIdentity    dH%    H;a   H   HD$    H$   HkH|$ WH    H    H$Hl$H\$ H\$    H\$ 1H9ttH\$(HH\$ H tvH\$1H9uHD$HhH`  1H9t$HhL`  A tH$   HĀ   H\$ H$    H\$ 1H9uH\$H$   HĀ   É    
      x  runtime.duffzero     8type.map[string]*"".Identity     &runtime.mapiterinit     &runtime.mapiternext     0runtime.morestack_noctxt      "".autotmp_0025 Btype.map.iter[string]*"".Identity  "".firstIdentity "type.*"".Identity "".~r0 "type.*"".Identity "".e  type.*"".Entity ,.  4	[&	  Z Tgclocals·32bd5c6dc84e3e86dd35593b3922d3aa Tgclocals·c00bf85eed6a8e40863dfe64526ae817   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go4"".(*Entity).encryptionKey    dH%    H$H;A  Hx  1H$  H$  H$  H$  HD$1H$   $  H$  H$  H    LS0HC8Hk@H$p  1H$h  HD$ L$`  Hl$ H9  LT$8I   IIJIjH|$(H|$H$H  H$   H$P  H$   H$X  H$   H$   Hmh   Y  H$   Hmk   =  H$   Hk@,$    L$  LT$8H|$(\$   H$   L$  L$0  D$  D$8  L$  L$@  H  1H9  1<    H$   $  $   L$   H$   H V   <   H$   H /  HK0s8$   Hk@H$   H$   $  T$xL$   H$   HD$pH9  H9  9< x  IHHl$ H9"H\$Ht~H$  H tlHK0HC8Hk@Hl$HH9sLHkHHHKHC1H$  H$  H$  H$  H$  Ƅ$  Hx      H$  H$    L$  H|$Hoh   tpH|$0Hok      Ik@,$    L$  H|$0\$ tmHGL$  D$  L$  H  1H9uu1< u=1IINHGL$  H$  H$  H$  Ƅ$  Hx  1H$  H$  H$  H$  Ƅ$   Hx  1HH0DH8LP@H  u Hi ʚ;1HI&.HIHHH?H)HHHDHI&.HIIIH?I)LHi ʚ;II)D؁ ʚ;|0H- ʚ;I9I9uA91H    }H ʚ;H\$H\$H$   H t'Hk0H$   k8$  Hk@H$  I16H   *11HH0DH8LX@H  u Hi ʚ;1HI&.HIHHH?H)HHHDHI&.HIIIH?I)LHi ʚ;II)D؁ ʚ;   H- ʚ;H$   $   L$   HL$@D$HL\$PD$   L$   H$  $   D$`L$(  L\$hL$   HL$XI9I9uA9Z1SH   G mH ʚ;`A(    W
        golang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanEncrypt     $runtime.panicindex     8"".(*Entity).primaryIdentity     golang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanEncrypt     0runtime.morestack_noctxt     L"".autotmp_0054  type."".Key "".autotmp_0053  type."".Key "".autotmp_0052  type.bool "".autotmp_0051  type.bool "".autotmp_0050  $type.time.Duration "".autotmp_0047  type.bool "".autotmp_0043 _type."".Subkey "".autotmp_0042 type.*"".Subkey "".autotmp_0041 type.int "".autotmp_0040 type.int "".autotmp_0039  type.int32 "".autotmp_0038  type.int64 "".autotmp_0037  type.int32 "".autotmp_0036  type.int64 "".autotmp_0035  type.int64 "".autotmp_0034  type.bool "".autotmp_0033  type.int32 "".autotmp_0032  type.int64 "".autotmp_0030  type.int64 "".autotmp_0027 / type.[]"".Subkey time.u·3 type.time.Time time.t·2 type.time.Time time.t·2 type.time.Time time.u·3 type.time.Time time.t·2 type.time.Time "".~r0 type.time.Time time.t·2 type.time.Time Xgolang.org/x/crypto/openpgp/packet.expiry·4 type.time.Time bgolang.org/x/crypto/openpgp/packet.currentTime·3 type.time.Time "".i "type.*"".Identity "".subkey type."".Subkey "".i type.int "".maxTime type.time.Time $"".candidateSubkey type.int "".~r2 type.bool "".~r1 @type."".Key "".now type.time.Time "".e  type.*"".Entity <"1  D	
8/	L	9:)"5=2	!
0!	  ] Tgclocals·600ee7d67c9c8255d714010babcfa954 Tgclocals·b7b1f8b35d2c0319a0b6f6545db4c972   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go."".(*Entity).signingKey    dH%    H$pH;A  H  1H$8  H$@  H$H  H$P  HD$H$  H   LS0HC8Hk@H$  1H$   HD$ L$   Hl$ H9  LT$0I {  IIJIjH|$(H|$H$   H$   H$   H$   H$   H$   H$   Hmh     H$   Hmj     H$   Hk@,$    LT$0H|$(\$   H$   L$   L$   D$(  D$   L$0  L$   H  1H9S  1< =  H\$H\$H\$Ht~H$  H tlHK0HC8Hk@Hl$HH9sLHkHHHKHC1H$  H$8  H$@  H$H  H$P  Ƅ$X  H      H$  H$    L$  Ht$Hnh   t@Hnj   tmHFL$   D$(  L$0  H  1H9uu1< u=1IINHFL$8  H$@  H$H  H$P  Ƅ$X  H  1H$8  H$@  H$H  H$P  Ƅ$X   H  1HH0DH8LP@H  } Hi ʚ;1HI&.HIHHH?H)HHHDHI&.HIIIH?I)LHi ʚ;II)D؁ ʚ;|0H- ʚ;I9I9uA91H    }H ʚ;IH1HH0DH8LX@H  u Hi ʚ;1HI&.HIHHH?H)HHHDHI&.HIIIH?I)LHi ʚ;II)D؁ ʚ;   H- ʚ;HL$hD$pL\$xHL$8D$@L\$HD$   L$   H$   $   D$XL$   L\$`L$   HL$PI9I9uA91H    vH ʚ;iA}.    

        zgolang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanSign     $runtime.panicindex   	  8"".(*Entity).primaryIdentity     0runtime.morestack_noctxt     >"".autotmp_0080  type."".Key "".autotmp_0079  type."".Key "".autotmp_0078  type.bool "".autotmp_0077  type.bool "".autotmp_0076  $type.time.Duration "".autotmp_0071 _type."".Subkey "".autotmp_0070 type.*"".Subkey "".autotmp_0069 type.int "".autotmp_0068 type.int "".autotmp_0067  type.int32 "".autotmp_0066  type.int64 "".autotmp_0065  type.int32 "".autotmp_0064  type.int64 "".autotmp_0063  type.int64 "".autotmp_0062  type.int32 "".autotmp_0061  type.int64 "".autotmp_0059  type.int64 "".autotmp_0056 / type.[]"".Subkey time.u·3 type.time.Time time.t·2 type.time.Time "".~r0 type.time.Time time.t·2 type.time.Time Xgolang.org/x/crypto/openpgp/packet.expiry·4 type.time.Time bgolang.org/x/crypto/openpgp/packet.currentTime·3 type.time.Time "".subkey type."".Subkey "".i type.int $"".candidateSubkey type.int "".~r2 type.bool "".~r1 @type."".Key "".now type.time.Time "".e  type.*"".Entity <"1 
 ZD	8']

9:P=2%   Tgclocals·49911706e77e6300db306d6db0912e94 Tgclocals·fb243b290e3147d06831a4c3432e1bbf   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go,"".EntityList.KeysById    dH%    H$ H;A  H  11H$  H$  H$  H$  H$  H$  H$   HD$X    H$   HD$PH$   HL$xH\$XHl$PH9M  H\$xLI(H]HH$  H9h  HD$`    LD$hIhH$   WH    H    H$Hl$H$   H\$    HT$hHL$`H$   1H9t[H$(  HH$   H   1H9g  HhHl$`H$   H$    HT$hHL$`H$   1H9u1H$   H$  H$  H$  H$   HH$  HZH$  H$  H$  H$  H$  HHH9n  H$  HHHk HH$   H\$Hl$H-    H,$    LD$hI    IP0I@8Ih@H$   1H$   HD$@H$   HHl$@H9Q  HD$pH   H8HpHhHL$HH$   H$   H$   H$   H$   H$   H$   Hm H]HH$  H9   1H$   H$   H$   H$   LD$hL$   H$   H$   H$   H$   H$   H$   H$  H$  H$  HHH9   H$  HHHk HH$   H\$Hl$H-    H,$    LD$hHL$HHD$pHHHl$@H9H\$xHH\$xH\$XHH\$XH\$XHl$PH9HĀ  H-    H,$HL$HD$HT$H\$     HL$(H\$0HT$8HHH$  H$  H$  ! +A H-    H,$HL$HD$HT$H\$     HL$(H\$0HT$8HHH$  H$  H$  DHhH`  1H9HhL`  A tHHP    
        runtime.duffzero     8type.map[string]*"".Identity     &runtime.mapiterinit     &runtime.mapiternext     type."".Key     (runtime.typedmemmove     type."".Key     (runtime.typedmemmove     type.[]"".Key     "runtime.growslice     type.[]"".Key     "runtime.growslice     0runtime.morestack_noctxt   p  $"".autotmp_0096 type."".Key "".autotmp_0095 type."".Subkey "".autotmp_0094 type.*"".Subkey "".autotmp_0093 type.int "".autotmp_0092 type.int "".autotmp_0091 type."".Key "".autotmp_0088  type.**"".Entity "".autotmp_0087 type.int "".autotmp_0086 type.int "".autotmp_0085  type.[]"".Subkey "".autotmp_0084 Btype.map.iter[string]*"".Identity "".autotmp_0082 $type."".EntityList "".subKey type."".Subkey "".selfSig dtype.*golang.org/x/crypto/openpgp/packet.Signature "".e type.*"".Entity "".keys @type.[]"".Key 
"".id 0type.uint64 
"".el  $type."".EntityList "" 	 f>^	u	*!.(VV	.	 " ~e Tgclocals·0c238911198547350f64f1a5c3f6eaea Tgclocals·7f7e31e410d386547ddc0047dc2faa98   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go6"".EntityList.KeysByIdUsage    dH%    HD$H;A  H   11H$   H$   H$  H$   H$H$   H\$H$   H\$H$   H\$    $   HT$ HD$(Hl$0HT$pHD$xH$   Hl$h1HD$`HD$@HT$XHl$@H9   HT$PH !  L
LBHzHjHt$HL$   L$   L$   L$   H$   H$   H$   H$   H$   Hk H ~H HHl$@H9vH   H$   HmHp  1H9uH$   Hmh          1H$   Hmi   t
HHHH$   Hmj   t
HHHH$   Hmk   t
HHHH$   Hml   t
HHHHH!8H$   H$   H$  HHH9wNH$   HHHk HH$   H\$Hl$H-    H,$    Ht$HHT$P$   H-    H,$HL$HD$HT$H\$     HL$(H\$0HT$8HHH$   H$  H$   d    
        ,"".EntityList.KeysById   	  type."".Key   	  (runtime.typedmemmove   
  type.[]"".Key   
  "runtime.growslice     0runtime.morestack_noctxt     "".autotmp_0113 ?type."".Key "".autotmp_0112 type.*"".Key "".autotmp_0111 type.int "".autotmp_0110 type.int "".autotmp_0109  type.uint8 "".autotmp_0108  type.uint8 "".autotmp_0107  type.uint8 "".autotmp_0104 type.[]"".Key "".autotmp_0103 type.[]"".Key "".key type."".Key "".keys Ptype.[]"".Key  "".requiredUsage @type.uint8 
"".id 0type.uint64 
"".el  $type."".EntityList "  ^;<1%




l78V7  n;W Tgclocals·d89baa940c5dd9c3413a865661528d54 Tgclocals·f3cd884107c94d2b58adda1e0ef3f9dc   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go8"".EntityList.DecryptionKeys    dH%    HD$H;A  H   11H$  H$   H$(  L$   H$  H$  H$   E1H$   HD$PL$   Hl$PI9  LD$pMLL$XI 9  IR0IB8Ij@H$   1H$   HD$@H$   HHl$@H9   HD$hH   H8HpHhHL$HH$   H|$xH$   H$   H$   H$   H$   1H9t?Hl$xHmh   t\Hl$xHml   uGHl$xHmk   u2HHHl$@H9QIIHl$PI9H   1H$   H$   H$   H$   LT$`L$   H\$xH$   H$   H$   H$   H$   H$  H$   H$(  HHH9wUH$   HHHk HH$   H\$Hl$H-    H,$    LT$`LL$XLD$pHL$HHD$hH-    H,$HL$HD$HT$H\$     HL$(H\$0HT$8HHH$   H$(  H$  ] A    
      	  type."".Key   	  (runtime.typedmemmove   	  type.[]"".Key   
  "runtime.growslice     0runtime.morestack_noctxt   `  "".autotmp_0127 ?type."".Key "".autotmp_0126 type."".Subkey "".autotmp_0125 type.*"".Subkey "".autotmp_0124 type.int "".autotmp_0123 type.int "".autotmp_0121  type.**"".Entity "".autotmp_0120 type.int "".autotmp_0119 type.int "".autotmp_0118  type.[]"".Subkey "".autotmp_0117 o$type."".EntityList "".subKey type."".Subkey "".e type.*"".Entity "".keys 0type.[]"".Key 
"".el  $type."".EntityList "  8;SNV  B] Tgclocals·6a5390a59b8d22a13b923714ec7f5cb9 Tgclocals·1bcec613e24368dd337b6dd546e388e5   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go*"".ReadArmoredKeyRing    dH%    H;as  Hp1H$   H$   H$   1H$   H$   H\$xH$H$   H\$    HT$HT$8HD$HL$ HL$HH-    H9   HD$@H$HL$H-    Hl$H-    Hl$    HT$8HL$HHD$@\$     H    H\$`HD$h   1H$   H$   H$   H    H$H    H\$H    H\$H\$`H\$HD$         H\$(H$   H\$0H$   HpHD$@H t/1H$   H$   H$   H$   H$   HpH   H
HBH-    H9   HL$PH$HD$XHD$H-    Hl$H-    Hl$    HT$8\$  tiH t_HZHH$HKHL$    Ht$Hl$HT$ HL$(HD$0H$   H$   H$   H$   H$   HpÉH   H
HL$PHBHD$XH-    H9u9H$HD$H-    Hl$H-    Hl$    HT$8\$  7H$    H    H\$HD$+   H|$H
HHJHO    H\$(H\$`H\$0H\$h1H$   H$   H$   H    H$H    H\$H    H\$H\$`H\$HD$         H\$(H$   H\$0H$   HpÉ    p6
        Pgolang.org/x/crypto/openpgp/armor.Decode     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     Bgo.string."no armored data found"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     "".PublicKeyType      "".PublicKeyType     "".PublicKeyType      runtime.eqstring     "".ReadKeyRing   	 """.PrivateKeyType   
  """.PrivateKeyType   
 """.PrivateKeyType   
   runtime.eqstring     ngo.string."expected public or private key block, got: "     *runtime.concatstring2     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     0runtime.morestack_noctxt   p  "".autotmp_0136  type.string "".autotmp_0135 ?type.string "".autotmp_0132  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0131 xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".err _type.error "".block oZtype.*golang.org/x/crypto/openpgp/armor.Block "".~r2 Ptype.error "".~r1  $type."".EntityList "".r  type.io.Reader H9
  8C4X/`i`
 , YT.Hi< Tgclocals·4c546aaa12bca0a07eec0d3ecf7c37e3 Tgclocals·07c886799a88ac80d684b8bca7c92573   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go"".ReadKeyRing    dH%    HD$H;A  H   111H$   H$   1H$   H$   H$   H$   H\$XH$   H\$`1H$   H$   H$   H$   H$   H$   H$   HD$P1H(HhHhH    H$    HD$H   HǄ$      HǄ$      HD$xHl$XH(Hl$`=       HhH\$PHCH$   Hk H$   Hk(H\$PH\$@1H\$hH\$pH\$@H$    H\$H\$HHD$HL$H$   H$   H   H    H$HD$HL$HD$        H$   H$   \$     HT$hHL$pH\$@H$    HD$HT$H$   H-    H9   H$   H$HT$H-    Hl$H-    Hl$    H$   \$  tJ1H$   H$   H$   H u(H u"H\$hH$   H\$pH$   H   H$   H 1H$   H$   H$   H    H$HT$HL$HD$        H$   H$   \$  HD$hHT$pH\$@H$    HD$HT$H$   H$   H$   H$   HHH9w5H$   HHl$H=     uH+H$Hl$    H-    H,$HL$HD$HT$H\$     HL$(HD$0HT$8HHH$   H$   H$   L@L$Hl$    HD$x#     *
        "type.[1]io.Reader     "runtime.newobject    (runtime.writeBarrier     "".ReadEntity     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     $runtime.assertI2T2     ,"".readToNextPublicKey     io.EOF     io.EOF    io.EOF     runtime.ifaceeq   
  ntype.golang.org/x/crypto/openpgp/errors.StructuralError     $runtime.assertI2T2     ,"".readToNextPublicKey    (runtime.writeBarrier     .runtime.writebarrierptr     $type."".EntityList     "runtime.growslice     .runtime.writebarrierptr     0runtime.morestack_noctxt   p  "".autotmp_0141  type.[]io.Reader "".autotmp_0140 _\type.golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0139 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0138  ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 type.io.Reader "".e type.*"".Entity ."".lastUnsupportedError type.error "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader "".err Ptype.error 
"".el  $type."".EntityList "".r  type.io.Reader "  rO*A
 P
#A
 @'('(S1# . Q6PA# Tgclocals·1f1dd8e7d89cf8bf3d8c95fe792f66ad Tgclocals·db08f305c468200e3cf791eda6a8ebaa   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go,"".readToNextPublicKey  
  
dH%    H;aT  Hx11H$   H$   1H\$hH\$pH$   H$    Ht$Ht$hHT$HT$pHD$HL$ H$   H-    H9uWH$   H$HL$H-    Hl$H-    Hl$    Ht$hHT$pH$   H$   \$  tHxH$   H tIH    H$HD$HL$HD$        \$  t1H$   H$   HxH1H9tH[H-    H9  HH   < YP H$   Ht$XHT$`H\$HHHCHKHHH9wDHkHHHkHHl$XH+Hl$`=     u	HkHxLCL$Hl$    H    H$HT$HD$HL$Hl$     HT$(HD$0HL$8H\$HH tFHHD$@HHkHKHT$P=     uHYH$HT$    HT$PHD$@<11     
        bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     $runtime.assertI2T2     dtype.*golang.org/x/crypto/openpgp/packet.PublicKey    (runtime.writeBarrier     .runtime.writebarrierptr     `type.[]golang.org/x/crypto/openpgp/packet.Packet     "runtime.growslice    (runtime.writeBarrier   	  .runtime.writebarrierptr   	  0runtime.morestack_noctxt   0  
Ngolang.org/x/crypto/openpgp/packet.p·2 ?\type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 _^type.*golang.org/x/crypto/openpgp/packet.Reader "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".err type.error "".packets  ^type.*golang.org/x/crypto/openpgp/packet.Reader <V  N+7^-	=X	  C`ZQ: Tgclocals·725f69b7ae8520ac59af51db7db265d1 Tgclocals·51562c45243a0c5ce48841e15ba48784   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go"".ReadEntity  V  VdH%    H$H;Am  H  1H$  H$  H    H$    H\$H$   H    H$HD$    HD$    HD$        HD$ H$   H   =       HCH$  H$    H$   Ht$HT$H$   HD$HL$ H$@  H$8  H t$HǄ$      H$  H$  HĨ  HH$  1H9tH[H-    H9%  HD$GH   =       H|$G   H1H9tH[H-    H9  HD$GH   =     G  HG|$G   H$  H$   H$   H\$xHHkHKHHH9   HkHHHkHH$   H+H$   =        HkH    H$h  HǄ$p  )   HǄ$      H    H$H    H\$H    H\$H$h  H\$HD$         H\$(H$  H\$0H$  HĨ  LCL$Hl$    bH    H$HT$HD$HL$Hl$     HT$(Hl$0HL$8H\$xH tLHHl$PHHkHKH$   =     uHH$HT$    H$   HD$PH   HoH y  =     Q  H/Hk@,$    \$    H    H$h  HǄ$p  )   HǄ$      H    H$H    H\$H    H\$H$h  H\$HD$         H\$(H$  H\$0H$  HĨ  HǄ$       1H$x  H$  H$  H$  H$    H\$H$  H\$H$  HD$HL$ H$0  H-    H9D  H$(  H$HL$H-    Hl$H-    Hl$    H$0  H$(  \$    H$   H]1H9tHH    H    H$h  HǄ$p     HǄ$      H    H$H    H\$H    H\$H$h  H\$HD$         H\$(H$  H\$0H$  HĨ  H$x  H$  H$  H$  1H$  HD$XH$  HHl$XH9   H$   H HL$`H$   H+H,$H$   HD$    HD$H\$H$@  H$8  H -  H$   HSHk HK(HHH9wxHk HH$   =     uOH+H$   HL$`HHHl$XH9NH$   H$  1H$  H$  HĨ  H$Hl$    H    H$HT$HD$HL$Hl$     HT$(Hl$0HL$8H$   H tQHHl$HHHk HK(H$   =     u	HSLCL$HT$    H$   HD$HH    H$h  HǄ$p  ,   HǄ$      H    H$H    H\$H    H\$H$h  H\$HD$         H\$(H$  H\$0H$  HĨ  H$(  H t$HǄ$      H$  H$  HĨ  H$  H$  H$H  H$H$P  HD$    L$   H$H  H$P  D$=7  =8B  H1H9tH[H-    H9  HH      YP1@8!  H$  H$  H$   H$  H$   HHD$pHHhHHHHH9wMHkHHHkHH$   H+H$   =     u	HkLCL$Hl$    H    H$HT$HD$HL$Hl$     HT$(Hl$0HL$8H\$pH tLHHl$HHHkHKH$   =     uHMH$HT$    H$   HD$H-H$   H$H$  H\$HL$H|$ tRHL$    HD$ HL$(H$0  H$(  H (HǄ$      H$  H$  HĨ  É%    =7  H1H9tH[H-    H9  HH      XP1@8'  H$  H$  H$   H$  H$   HH$   HHhHHHHH9wMHkHHHkHH$   H+H$   =     u	HkLCL$Hl$    H    H$HT$HD$HL$Hl$     HT$(Hl$0HL$8H$   H tLHHl$HHHkHKH$   =     uHJH$HT$    H$   HD$H*H$   H$H$  H\$HD$HD$        HD$ HL$(H$0  H$(  H 9HǄ$      H$  H$  HĨ  H$   H$    11/119=Y}  H1H9tH[H-    H9?  HH    L  H$       H$x  H$  H$  HHH9w0H$  H=     uH;^H$H|$    KH-    H,$HL$HD$HT$H\$     H$   HL$(H\$0HT$8HHH$  H$  H$x  z1I9   H    H$h  HǄ$p  ,   HǄ$      H    H$H    H\$H    H\$H$h  H\$HD$         H\$(H$  H\$0H$  HĨ  IP Ih(IH0HHH9w,Ih(H=     uH;H$H|$    H    H$HT$HD$HL$Hl$     H$   HT$(Hl$0HL$8H$   H tYHHl$HHHk(HK0H$   =     u	HS bLC L$HT$    H$   H$   HD$H6=_IFH1H9tH[H-    H9  H$   H   < H    H$    HD$H$   H ^  H$   H E  HD$Hl$H-    H,$    H$   H   H$   =       HkH$   H$   H    H$H$   HkHl$H$   H\$H|$   H$   H\$    H$  H$    H$   H\$H$  H\$H$  HD$HL$ H$0  H-    H9   H$(  H$HL$H-    Hl$H-    Hl$    H$   H$0  H$(  \$  t2HǄ$      H    H$  H    H$  HĨ  H$(  H t$HǄ$      H$  H$  HĨ  H$  1H9tH[H-    H9J  H$  H   I<    H    H$h  HǄ$p  -   HǄ$      H    H$H    H\$H    H\$H$h  H\$HD$         H\$(H$  H\$0H$  HĨ     LL$hA   H$   HS Hk(HK0HHH9w,Hk(H=     uLH$LL$    H    H$HT$HD$HL$Hl$     LL$hHT$(Hl$0HL$8H$   H tVHHl$PHHk(HK0H$   =     u	HS eLC L$HT$    LL$hH$   HD$P<LL$hIX  1H9IX  H] LIhHH9H*H,$H$   H|$HHHNHOH*Hl$LL$     HD$(HL$0H$0  H$(  H    H$HX HL$HD$H$    H    H\$HD$    H$X  HL$H$`  HD$     H\$(H$h  H\$0H$p  HǄ$      H    H$H    H\$H    H\$H$h  H\$HD$         H\$(H$  H\$0H$  HĨ  H$   H t.Hl$h=     u	HkLCL$Hl$    11%    cLCL$Hl$     E HǄ$       1X11H<$Hl$    H$   E jLGL$HD$    H$   H$  H$   v1D$G `H<$HD$    H$   H$  H$   1D$G LCL$HD$    #    n
      n  type."".Entity     "runtime.newobject     8type.map[string]*"".Identity     runtime.makemap    (runtime.writeBarrier     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     dtype.*golang.org/x/crypto/openpgp/packet.PublicKey    (runtime.writeBarrier     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey    (runtime.writeBarrier    (runtime.writeBarrier     jgo.string."first packet was not a public/private key"   	  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   	  type.error   	  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   	  runtime.convT2I   
  .runtime.writebarrierptr   
  `type.[]golang.org/x/crypto/openpgp/packet.Packet     "runtime.growslice    (runtime.writeBarrier     .runtime.writebarrierptr    (runtime.writeBarrier     zgolang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanSign     jgo.string."primary key cannot be used for signatures"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     Rgo.string."entity without any identities"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifyRevocationSignature    (runtime.writeBarrier     .runtime.writebarrierptr     htype.[]*golang.org/x/crypto/openpgp/packet.Signature     "runtime.growslice    (runtime.writeBarrier     .runtime.writebarrierptr     pgo.string."revocation signature signed by alternate key"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I      $runtime.ifacethash   !  ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey   $ (runtime.writeBarrier   $  .runtime.writebarrierptr   $  `type.[]golang.org/x/crypto/openpgp/packet.Packet   %  "runtime.growslice   & (runtime.writeBarrier   &  .runtime.writebarrierptr   '  "".addSubkey   )  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey   + (runtime.writeBarrier   ,  .runtime.writebarrierptr   ,  `type.[]golang.org/x/crypto/openpgp/packet.Packet   -  "runtime.growslice   . (runtime.writeBarrier   .  .runtime.writebarrierptr   /  "".addSubkey   1  dtype.*golang.org/x/crypto/openpgp/packet.Signature   3 (runtime.writeBarrier   3  .runtime.writebarrierptr   3  htype.[]*golang.org/x/crypto/openpgp/packet.Signature   4  "runtime.growslice   5  pgo.string."signature packet found before user id packet"   6  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   6  type.error   6  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   7  runtime.convT2I   8 (runtime.writeBarrier   8  .runtime.writebarrierptr   8  htype.[]*golang.org/x/crypto/openpgp/packet.Signature   9  "runtime.growslice   : (runtime.writeBarrier   :  .runtime.writebarrierptr   ;  ^type.*golang.org/x/crypto/openpgp/packet.UserId   <   type."".Identity   <  "runtime.newobject   =  type.string   =  (runtime.typedmemmove   > (runtime.writeBarrier   >  8type.map[string]*"".Identity   ?  $runtime.mapassign1   ?  bgolang.org/x/crypto/openpgp/packet.(*Reader).Next   @  io.EOF   A  io.EOF   A io.EOF   A  runtime.ifaceeq   B  &io.ErrUnexpectedEOF   B &io.ErrUnexpectedEOF   D  dtype.*golang.org/x/crypto/openpgp/packet.Signature   D  rgo.string."user ID packet not followed by self-signature"   E  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   E  type.error   E  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   F  runtime.convT2I   H (runtime.writeBarrier   H  .runtime.writebarrierptr   H  htype.[]*golang.org/x/crypto/openpgp/packet.Signature   I  "runtime.growslice   J (runtime.writeBarrier   J  .runtime.writebarrierptr   L  golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifyUserIdSignature   M       M  Xgo.string."user ID self-signature invalid: "   N  *runtime.concatstring2   O  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   O  type.error   O  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   O  runtime.convT2I   P (runtime.writeBarrier   Q  .runtime.writebarrierptr   R  .runtime.writebarrierptr   S  .runtime.writebarrierptr   S  .runtime.writebarrierptr   T  .runtime.writebarrierptr   U  .runtime.writebarrierptr   V  0runtime.morestack_noctxt   @  N"".autotmp_0173  dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0172 ftype.**golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0171 type.int "".autotmp_0170  type.int "".autotmp_0168  type.bool "".autotmp_0167 \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0166  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0165 /htype.[]*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0164  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0163 type.int "".autotmp_0162  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0161  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0160 type.string "".autotmp_0159  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0157 "type.*"".Identity "".autotmp_0156  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0154 ntype.golang.org/x/crypto/openpgp/errors.StructuralError Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".revocation dtype.*golang.org/x/crypto/openpgp/packet.Signature "".pkt \type.golang.org/x/crypto/openpgp/packet.Packet "".pkt dtype.*golang.org/x/crypto/openpgp/packet.Signature "".sig dtype.*golang.org/x/crypto/openpgp/packet.Signature "".pkt ^type.*golang.org/x/crypto/openpgp/packet.UserId "".err type.error "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".revocations _htype.[]*golang.org/x/crypto/openpgp/packet.Signature "".current "type.*"".Identity 
"".ok type.bool "".err type.error "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".e type.*"".Entity "".~r2  type.error "".~r1 type.*"".Entity "".packets  ^type.*golang.org/x/crypto/openpgp/packet.Reader "11 + 4S=$SLl(=\ X3;"*$Tw*)*)B$	[<fz>$N<;KLKL^+[\[\M@>+WE`2$53%&%&2X =>=>	%B>  ?84	)TNsYj&\{)TF
)WB`)dnCr# )a1/
Y0E'.) Tgclocals·59a081aa56aea3db12c49708a232e907 Tgclocals·13f87cc0608ea5e3ee364165a76a979f   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go"".addSubkey    dH%    HD$H;A%  H   1H$   H$   1H$   H$   H$   H$   H$   H$   H$   H$   H$    H\$H\$PH\$H\$XHD$HL$ HL$hH-    H9ueHD$`H$HL$H-    Hl$H-    Hl$    HL$hHD$`\$  t&H    H$   H    H$   HĨ   HD$`H    H$HX HL$HD$H$    H    H\$HD$   H$   HL$H$   HD$     H\$(H\$pH\$0H\$xH    H$H    H\$H    H\$H\$pH\$HD$         H\$(H$   H\$0H$   HĨ   H\$P1H9tH[H-    H94  HD$XH   H$    urH    H\$pHD$x'   H    H$H    H\$H    H\$H\$pH\$HD$         H\$(H$   H\$0H$   HĨ   H$   Hm]    H$   Hm] (trH    H\$pHD$x    H    H$H    H\$H    H\$H\$pH\$HD$         H\$(H$   H\$0H$   HĨ   H$   H+H,$H$   H\$H$   H\$    HD$HL$ HL$hHD$`H    H$HX HL$HD$H$    H    H\$HD$   H$   HL$H$   HD$     H\$(H\$pH\$0H\$xH    H$H    H\$H    H\$H\$pH\$HD$         H\$(H$   H\$0H$   HĨ   H$   HS0HC8HK@HHH9wMHk8HHHkHH$   H\$Hl$H-    H,$    1H$   H$   HĨ   H    H$HT$HD$HL$Hl$     HT$(HD$0HL$8H$   H tKHHD$@HHk8HK@HT$H=     u	HS0LLC0L$HT$    HT$HHD$@+11    R
        bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     &io.ErrUnexpectedEOF    &io.ErrUnexpectedEOF            Lgo.string."subkey signature invalid: "     *runtime.concatstring2     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     dtype.*golang.org/x/crypto/openpgp/packet.Signature     fgo.string."subkey packet not followed by signature"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error   	  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   	  runtime.convT2I   
  Xgo.string."subkey signature with wrong type"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifyKeySignature            Lgo.string."subkey signature invalid: "     *runtime.concatstring2     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     type."".Subkey     (runtime.typedmemmove      type.[]"".Subkey     "runtime.growslice    (runtime.writeBarrier     .runtime.writebarrierptr     0runtime.morestack_noctxt   `  "".autotmp_0201  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0200  type.string "".autotmp_0199  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0198  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0196 ontype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0195 Otype.string "".err type.error "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".subKey /type."".Subkey "".~r4 @type.error "".priv 0ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".pub  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader "".e  type.*"".Entity fk 
 b14K&4r.r=R	 4 wZV+t>Y4 Tgclocals·cc66687e142fc5da495a1664db6f640f Tgclocals·a3f332e265628a83ebf74125fa889474   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go"".NewEntity  -  -dH%    H$HH;A  H8  1H$  H$  H$p  H$    H$p  H\$H$   \$$   H\$H$   HD$H   1H9tHX@H t	Hh@Hl$HH$@  H$H$H  H\$H$P  H\$H$X  H\$H$`  H\$ H$h  H\$(    HD$0HD$P1H9   H    H$   HǄ$   *   HǄ$x      H    H$H    H\$H    H\$H$   H\$HD$         H\$(H$  H\$0H$  H8  H$p  11H9	  H(H }	  HH@H$   H$H$   HD$H\$HH\$    H\$H\$XHD$ HL$(H$   H$   H t$HǄ$x      H$  H$  H8  H$p  11H9  H(H   HH@H$   H$H$   HD$H\$HH\$    H\$H\$`HD$ HL$(H$   H$   H t$HǄ$x      H$  H$  H8  H$   H$$   \$H$   H\$H\$XH\$H|$       H\$ H$   H$   H$$   \$H$   H\$H\$XH\$    H\$ H$   H    H$HD$    HD$    HD$        H\$ H$   H    H$    HD$HH U  W    GH$   H$   =       H(H   H$   =       HhH   H$   =       HhHD$hH    H$    HD$H$    H$p  1H96  HXH (  HhHl$@H    H$    HD$1H(HhHhHhHh Hh(Hh0H\$PH   HkHD$xHD$Hl$H-    H,$    H\$xH   Hl$P=     u  HkH    H$    HD$HH H  WH    HD$pH$   Hh0$   h8H$   =       Hh@ @Hl$@HhH$   =       H`  H   @h  H   @j  H   @i  LD$hI(H ]  HH=     -  HX  H\$xH   =       HCH\$xH$   H    H$H\$hHkHl$H\$PH\$H|$   H$   H\$    H    H$HD$   HD$       HT$HL$ HD$(H\$hH G  H$(  HK8H$0  HC@H$   =       HS0H$   H$$   \$H$   H\$H\$`H\$H|$       H\$ H$   H$   H$$   \$H$   H\$H\$`H\$    HL$ H$p  1H9N  HXH @  HhHl$81H$  H$  H$  H$   H$  H$  H    H$    HD$HH   WH    HD$pH$   Hh0$   h8H$   =       Hh@ @Hl$8HhH   @h  H   @l  H   @k  LD$hI(H ,  HH=        HX  H$  H\$hH    HK0HC8Hk@H$0  H$   H H$(     H$  HL$Hl$H-    H,$    HT$hH tqHJ0HB8Hj@H vXHH   @kPHJ0HB8Hj@H v1HYH   @kPH$x  1H$  H$  H8              "LX  L$Hl$    HD$pE L@@L$Hl$    HD$pd HD$8   %    ;LC0L$HT$    %    TLCL$HD$    LX  L$Hl$    HD$pE L`  L$Hl$    HD$p@L@@L$Hl$    HD$p LCL$Hl$    x["HD$@   L@L$Hl$    H$   e EL@L$Hl$    H$    H$Hl$    H$    %    H    H    )H    H    w    ̆
        `golang.org/x/crypto/openpgp/packet.(*Config).Now     Xgolang.org/x/crypto/openpgp/packet.NewUserId     lgo.string."user id field contained invalid characters"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     ,crypto/rsa.GenerateKey   	  ,crypto/rsa.GenerateKey     dgolang.org/x/crypto/openpgp/packet.NewRSAPublicKey     fgolang.org/x/crypto/openpgp/packet.NewRSAPrivateKey     8type.map[string]*"".Identity     runtime.makemap     type."".Entity     "runtime.newobject     runtime.duffzero    (runtime.writeBarrier    (runtime.writeBarrier    (runtime.writeBarrier     type.bool     "runtime.newobject      type."".Identity     "runtime.newobject     type.string     (runtime.typedmemmove    (runtime.writeBarrier     btype.golang.org/x/crypto/openpgp/packet.Signature     "runtime.newobject     runtime.duffzero    (runtime.writeBarrier    (runtime.writeBarrier    (runtime.writeBarrier    (runtime.writeBarrier     8type.map[string]*"".Identity     $runtime.mapassign1      type.[]"".Subkey     "runtime.makeslice    (runtime.writeBarrier     dgolang.org/x/crypto/openpgp/packet.NewRSAPublicKey     fgolang.org/x/crypto/openpgp/packet.NewRSAPrivateKey     btype.golang.org/x/crypto/openpgp/packet.Signature     "runtime.newobject     runtime.duffzero    (runtime.writeBarrier   ! (runtime.writeBarrier   "  type."".Subkey   "  (runtime.typedmemmove   $  $runtime.panicindex   $  $runtime.panicindex   %  $runtime.panicindex   %  .runtime.writebarrierptr   &  .runtime.writebarrierptr   &  .runtime.writebarrierptr   '  .runtime.writebarrierptr   (  .runtime.writebarrierptr   (  .runtime.writebarrierptr   )  .runtime.writebarrierptr   )  .runtime.writebarrierptr   *  .runtime.writebarrierptr   +  .runtime.writebarrierptr   +  .runtime.writebarrierptr   ,  $crypto/rand.Reader   , $crypto/rand.Reader   ,  $crypto/rand.Reader   , $crypto/rand.Reader   ,  0runtime.morestack_noctxt     >"".autotmp_0217  dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0216 _type."".Subkey "".autotmp_0215 dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0214 "type.*"".Identity "".autotmp_0213 type.*"".Entity "".autotmp_0212  ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".autotmp_0211  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey "".autotmp_0210 / type.[]"".Subkey "".autotmp_0209 "type.*"".Identity "".autotmp_0208 8type.map[string]*"".Identity "".autotmp_0207 ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".autotmp_0206 dtype.*golang.org/x/crypto/openpgp/packet.PublicKey "".autotmp_0205 xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".&isPrimaryId type.*bool "".~r0  type.crypto.Hash "".~r0  type.crypto.Hash "".~r0 type.io.Reader "".~r0 type.io.Reader "".e type.*"".Entity """.encryptingPriv 6type.*crypto/rsa.PrivateKey "".err type.error "".signingPriv 6type.*crypto/rsa.PrivateKey "".uid ^type.*golang.org/x/crypto/openpgp/packet.UserId "".bits type.int "".currentTime type.time.Time "".~r5 type.error "".~r4 ptype.*"".Entity "".config `^type.*golang.org/x/crypto/openpgp/packet.Config "".email @type.string "".comment  type.string "".name  type.string L"  4>		Wm$m$L@
 *2Wi		FJNqL8
*2i32d&!"J	.#	O  @zs@8JT"qs-0,a*!C#3&"V Tgclocals·092fba05dc9a1d750fd3f830d20d2ea3 Tgclocals·b23e7c8f52cf08edb06e25e1ada78141   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go:"".(*Entity).SerializePrivate    dH%    H$xH;A  H  11H$0  H$8  H$  HkH,$H$  H\$H$   H\$    HD$H\$ H$8  H$0  H tH  H$  HkH$   WH    H    H$Hl$H$   H\$    H$   1H9`  H$   H+H$   H   Hl$PHmH,$H$  H\$H$   H\$    H$  HD$PHL$H\$ H$8  H$0  H tH  HhH,$HXH|$HHHKHOH*Hl$HjHl$ H$(  H\$(    HD$0H\$8H$8  H$0  H tH  H\$PHkH,$H$  H\$H$   H\$    HD$H\$ H$8  H$0  H tH  H$   H$    H$   1H9H$  H   HS0HC8Hk@H$   1H$   HD$@H$   HHl$@H9^  HHD$XH f  H0H@HkHL$HHt$xHt$`H$   H$   Hl$pHD$hH$H$  H\$H$   H\$    HD$H\$ H$8  H$0  H tH  H\$pH$H\$`H\$H$  HkHl$H$(  H\$    HD$ H\$(H$8  H$0  H tH  H\$pH$H$  H\$H$   H\$    HD$H\$ H$8  H$0  H tH  HD$XHL$HHHHl$@H91H$0  H$8  H  É >    
        tgolang.org/x/crypto/openpgp/packet.(*PrivateKey).Serialize     runtime.duffzero     8type.map[string]*"".Identity     &runtime.mapiterinit     lgolang.org/x/crypto/openpgp/packet.(*UserId).Serialize     tgolang.org/x/crypto/openpgp/packet.(*Signature).SignUserId     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize     &runtime.mapiternext     tgolang.org/x/crypto/openpgp/packet.(*PrivateKey).Serialize     ngolang.org/x/crypto/openpgp/packet.(*Signature).SignKey     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize     0runtime.morestack_noctxt   `  "".autotmp_0228 type."".Subkey "".autotmp_0227 type.*"".Subkey "".autotmp_0226 type.int "".autotmp_0225 type.int "".autotmp_0223  type.[]"".Subkey "".autotmp_0222 Btype.map.iter[string]*"".Identity "".subkey type."".Subkey "".ident "type.*"".Identity "".err @type.error "".config 0^type.*golang.org/x/crypto/openpgp/packet.Config "".w type.io.Writer "".e  type.*"".Entity v"jiS]O8  6ArKT>$:H: & `j\ Tgclocals·cc66687e142fc5da495a1664db6f640f Tgclocals·3ad51b90552f8e39bfd16e2811d6b9a2   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go,"".(*Entity).Serialize    dH%    H$`H;A'  H   1H$@  H$H  H$(  H+H,$H$0  H\$H$8  H\$    HD$HL$ HL$XHD$PH tH$@  H$H  H   H$(  HkH$   WH    H    H$Hl$H$   H\$    H$   1H9  H$   H+H$   H 5  Hl$8HmH,$H$0  H\$H$8  H\$    HD$HL$ HL$XHD$PH tH$@  H$H  H   H\$8HkH,$H$0  H\$H$8  H\$    HD$HL$ HL$XHD$PH tH$@  H$H  H   H\$8H c  HS HC(Hk0H$   1H$   HD$(H$   HHl$(H9}}HD$HH(HL$0H,$H$0  H\$H$8  H\$    HD$HL$ HL$XHD$PH tH$@  H$H  H   HD$HHL$0HHHl$(H9|H$   H$    H$   1H9?H$(  H q  HS0HC8Hk@H$   1H$   HD$(H$   HHl$(H9  HHD$@H   H HsHkHL$0HD$xH$   Ht$hH$   Hl$pHD$`H$H$0  H\$H$8  H\$    HD$HL$ HL$XHD$PH tH$@  H$H  H   H\$pH$H$0  H\$H$8  H\$    HD$HL$ HL$XHD$PH tH$@  H$H  H   HD$@HL$0HHHl$(H91H$@  H$H  H   É     
        rgolang.org/x/crypto/openpgp/packet.(*PublicKey).Serialize     runtime.duffzero     8type.map[string]*"".Identity     &runtime.mapiterinit     lgolang.org/x/crypto/openpgp/packet.(*UserId).Serialize     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize   
  &runtime.mapiternext     rgolang.org/x/crypto/openpgp/packet.(*PublicKey).Serialize     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize     0runtime.morestack_noctxt   P   "".autotmp_0241 type."".Subkey "".autotmp_0240 type.*"".Subkey "".autotmp_0239  type.int "".autotmp_0238  type.int "".autotmp_0236 ftype.**golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0235 type.int "".autotmp_0234 type.int "".autotmp_0232  type.[]"".Subkey "".autotmp_0231 htype.[]*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0230 Btype.map.iter[string]*"".Identity "".subkey type."".Subkey "".ident "type.*"".Identity "".err type.error "".~r1 0type.error "".w type.io.Writer "".e  type.*"".Entity l"q]Y8  4=r;;T2$ 77 ( ]t\^Z Tgclocals·b385d9a51ca4f468987863aa65654328 Tgclocals·bdba11b0e20d0b4a0d5c7fb1c5481022   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go2"".(*Entity).SignIdentity    dH%    HD$H;A  H   H$   1H$   H$   HX1H9u{H    H$   HǄ$   &   H    H$H    H\$H    H\$H$   H\$HD$         H\$(H$   H\$0H$   Hĸ   Hh(   t{H    H$   HǄ$   .   H    H$H    H\$H    H\$H$   H\$HD$         H\$(H$   H\$0H$   Hĸ   H$   H$   H    H$H$   HkHl$H$   HL$H$   HD$    H$   HL$ \$(H)Hl$X u{H    H$   HǄ$   )   H    H$H    H\$H    H\$H$   H\$HD$         H\$(H$   H\$0H$   Hĸ   1H9  HZH   HjHl$@H$    H\$H$   \$$   H\$H$   H    H$    H|$HH W  WH     L$   M@Ah@hHl$@HhHD$hH$   Hh0$   h8H$   =       Hh@H   L$   IhH   HH=     {  HX  HD$PH$H$   H\$H$   H\$H$   H+Hl$H$   HkHl$ H$   H\$(    HD$0HL$8HL$xHD$pH tH$   H$   Hĸ   H\$XHS Hk(HK0HHH9wCHk(HHl$P=     uH+1H$   H$   Hĸ   H$Hl$    H    H$HT$HD$HL$Hl$     HT$(Hl$0HL$8H\$XH tKHHl$HHHk(HK0HT$`=     u	HS YLC L$HT$    HT$`HD$H8LX  L$Hl$    HD$hmE M 0L@@L$Hl$    HD$h
HD$@   D    D
        dgo.string."signing Entity must have a private key"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     tgo.string."signing Entity's private key must be decrypted"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     8type.map[string]*"".Identity     4runtime.mapaccess2_faststr     jgo.string."given identity string not found in Entity"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I   	  `golang.org/x/crypto/openpgp/packet.(*Config).Now   
  btype.golang.org/x/crypto/openpgp/packet.Signature   
  "runtime.newobject   
  runtime.duffzero    (runtime.writeBarrier    (runtime.writeBarrier     tgolang.org/x/crypto/openpgp/packet.(*Signature).SignUserId    (runtime.writeBarrier     .runtime.writebarrierptr     htype.[]*golang.org/x/crypto/openpgp/packet.Signature     "runtime.growslice    (runtime.writeBarrier     .runtime.writebarrierptr     .runtime.writebarrierptr     .runtime.writebarrierptr     0runtime.morestack_noctxt   p  "".autotmp_0248 dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0246 /type.time.Time "".autotmp_0245  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0244 otype.string "".autotmp_0243  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0242 Oxtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".~r0  type.crypto.Hash "".err type.error "".sig dtype.*golang.org/x/crypto/openpgp/packet.Signature "".ident "type.*"".Identity "".~r3 Ptype.error "".config @^type.*golang.org/x/crypto/openpgp/packet.Config "".signer 0type.*"".Entity "".identity type.string "".e  type.*"".Entity XN 
 z	9{{e{".1=8p5		 6 xM5	&
V(b Tgclocals·949580c181e84412df3073e61f463446 Tgclocals·5162572c77809d4735df497e4a91f652   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/keys.go"".readArmored    dH%    H;a  H   111H$   H$   1H$   H$   H$   H$H$   H\$    H$   HL$HD$H\$ H$   H$   H tHĀ   HL$XH k  H1Ht$`HAHD$hH9usH4$HD$H$   Hl$HT$    H$   HL$X\$  t<H t2HiH$   Hi H$   1H$   H$   HĀ   ÉH$    H    H\$HD$
   H$   H\$HT$ H    H\$(HD$0   H|$8HH	HHNHO    H\$HH\$pH\$PH\$xH    H$H    H\$H    H\$H\$pH\$HD$         HL$(HD$01H$   H$   H$   H$   HĀ   É    
        Pgolang.org/x/crypto/openpgp/armor.Decode      runtime.eqstring     ,go.string."expected '"     (go.string."', got: "     *runtime.concatstring4     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     0runtime.morestack_noctxt     "".autotmp_0253 ?type.string "".autotmp_0252 xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".block OZtype.*golang.org/x/crypto/openpgp/armor.Block "".err `type.error "".body @type.io.Reader "".expectedType  type.string "".r  type.io.Reader :z
  (2B=\<
  [zOJ Tgclocals·537385343e646e25b1b6fced99dbb969 Tgclocals·79d0667feac83fcec4421590bfc5b188   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/read.go"".ReadMessage  Z  ZdH%    H$H;A`  H  11H$  H$  1H$   H$(  1H$   H$  H$  1H$  H$   H$(  H$  H$   H$  H$   H    H$    HD$H$   1H(HhHhH    H$    HD$H   HǄ$     HǄ$     H$  H$   H(H$   =     0  HhH$   H$  Hk H$  Hk(=       HCH$   H$   H    H$    HD$H$  H   @(H$   H$    HL$HD$HT$H\$ H$  H$  H tHǄ$      HĈ  H$   H$(  H$  H$H$  HD$    L$  H$  H$  H$  D$=sR  =jq%T  H1H9tH[H-    H9  H    &  H$0  H$8  I   H$   H s  H$   H$  H$  H$   HHCHKHHH9   HkHHHkHH$  H+H$  =     ugHkH$   H$HD$    H$  H\$H$  H\$    HD$ HT$(HL$0H$  H$  H$  HĈ  LCL$Hl$    H    H$HT$HD$HL$Hl$     HT$(HD$0HL$8H$   H tLHHD$`HHkHKH$   =     uHH$HT$    H$   HD$`H    H$  HǄ$  .   H    H$H    H\$H    H\$H$  H\$HD$         HL$(HD$0HǄ$      H$  H$  HĈ  =:>   H1H9tH[H-    H9  H$   H       H   @o H$   H$  LLHH9w8H$  HH$   =     uH+fH$Hl$    SH-    H,$HL$HD$HT$H\$     HL$(HD$0HT$8HHH$  H$  H$   z=sRH1H9tH[H-    H9  H   < H$   1H$x  H$  1H$  H$  H$  HǄ$      1H$  $  $  $  H$  H$  H$  H$  H$  WH    GH    H$HD$    H$  H\$H$  H\$    H\$ H$   H$  H$   H$(  H$  HD$p    H$  HD$xH$  H$   H\$pHl$xH9   H$   H 
  H;HsHSHKHk H$p  H$H  H$x  H$P  H$  H$X  H$  H$`  H$  H$h  H$X  1H9o  H$   H(H$   H\$pHH\$pH\$pHl$xH9DH$  H u@H$  H u2H    H    HǄ$      H$  H$  HĈ  H$  1H9u2H    H    HǄ$      H$  H$  HĈ  H$  H$x  H$H$  H\$H$  H\$H D$H$  HH$  H\$ H$0  H\$(H$8  H\$0H$@  HD$8HT$@H$x  H$p  H t$HǄ$      H$  H$  HĈ  H H$0  H H$   H$  HH$  1H$  HD$hH$  HHl$hH9H$   H(H$   H,$H$0  H\$H$8  H\$H$@  H\$    Ht$ H$`  Hl$(H$h  HT$0H$p  \$8HHL$@H\$HH$h  H$`  H   H$   H$D$Ht$Hl$HT$     H\$(H$  H\$0H$  HD$8HL$@H$h  H$`  H tTH-    H9n  H$HL$H-    Hl$H-    Hl$    H$h  H$`  \$  *  H$  H   H$  H$  H   H$  =       H   H$   H$   H    H$H$  H\$H$  H\$    H$   HL$HD$ H$  H$   H$  H$  1H$P  H$X  Hj H $  H    H$  HǄ$     H    H$H    H\$H    H\$H$  H\$HD$         HD$(HL$0H$  H$  H$P  H$X  H$  H$  H t$HǄ$      H$  H$  HĈ  H$   H$H$  H\$H$  H\$H$  H\$    HD$ HT$(HL$0H$  H$  H$  HĈ  HHRHC HK(HHH9wOHk HHHkHH$   H+H$  =     uHk1HLCL$Hl$    H    H$HT$HD$HL$Hl$     HT$(HD$0HL$8H$   H tQHHD$XHHk HK(H$   =     u	HSGLCL$HT$    H$   HD$X#L   L$Hl$    7H$   H$   HHHǄ$      H$  H$  HĈ  H$H  Hm(     H$h  HkH u+H$h  H$H$X  H\$H$  H\$    H$h  HkH "H$   H$H$H  H[ k	@l$H$h  H   HkH|$HM HHMHOHMHO    H\$(H$  H\$0H$  HD$8HL$@H$  H$  H t@H-    H9   H$HL$H-    Hl$H-    Hl$    \$  tPH$  H >H$H  H$  H t#LE(LD$H\$H    H$    8E HǄ$      HĈ  ÉH$P  H   H0H   H   H   H$    H$  HD$H$  HT$H$  HL$    HL$ HD$(H$@  H$H  H    H$H$   H\$H$  HL$H$  HD$    H\$ +@  H$H  H$(  H$P  H$0  H$X  H$8  H$`  H$@  H$x  H$  H$  HHH9   H$  HHHk HH$(  H\$Hl$H-    H,$    H$@  H$  H$H  H$  D$WH    H$H$   H\$H$  H\$H\$WH\$    $H-    H,$HL$HD$HT$H\$     HL$(HD$0HT$8HHH$  H$  H$x    C11HǄ$       11= ^u.H1H9tH[H-    H9$  H    S= 	}  H1H9tH[H-    H9  HH      H$   H.H$   HWHGHOHHH9  HoHH$   H+n@  1H$H  H$P  H$X  HH '  H$  H$H$  H[ HT$HL$HD$H$H  HH$P  HH$X  H$   1H$  HT$pH$  HHl$pH9EH$   H   H(H$(  HhH$0  HhH$8  HhH$@  HL$xH$(  H$0  H$8  H$@  1H$  H$  H$  H$  H$  H$  H$  H$  H$  H$  H$  H$   H$  H$   H$  H$  H$   H$(  HHH9wPH$   HHHk(HH$  H\$Hl$H-    H,$    H$   HL$xH HH-    H,$HL$HD$HT$H\$     HL$(HD$0HT$8HHH$   H$(  H$  b bH.Hl$H$  H$H$  H[(HT$HL$HD$ @r@hFH    H$HT$HD$HL$Hl$     H$   HT$(HD$0HL$8H$  H tYHHD$`HHkHKH$   =     u	HSLCL$HT$    H$   H$   HD$`=֤H1H9tH[H-    H9uH   < Qg1111LCL$HD$    L@L$Hl$    H$   j    {̺
        \type.golang.org/x/crypto/openpgp/packet.Reader     "runtime.newobject     "type.[1]io.Reader     "runtime.newobject    (runtime.writeBarrier    (runtime.writeBarrier     ,type."".MessageDetails     "runtime.newobject     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     $runtime.ifacethash   	  htype.*golang.org/x/crypto/openpgp/packet.LiteralData    (runtime.writeBarrier     ("".readSignedMessage     .runtime.writebarrierptr     `type.[]golang.org/x/crypto/openpgp/packet.Packet     "runtime.growslice    (runtime.writeBarrier     .runtime.writebarrierptr     tgo.string."key material not followed by encrypted message"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted    (runtime.writeBarrier     .runtime.writebarrierptr     type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted     "runtime.growslice     ~type.*golang.org/x/crypto/openpgp/packet.SymmetricallyEncrypted     runtime.duffzero     (type.map[string]bool     runtime.makemap     dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect    dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect      dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect     dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   "       &  golang.org/x/crypto/openpgp/packet.(*SymmetricKeyEncrypted).Decrypt   (  golang.org/x/crypto/openpgp/packet.(*SymmetricallyEncrypted).Decrypt   )  dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   )  dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   ) dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   *  runtime.ifaceeq   + (runtime.writeBarrier   +  type.io.Reader   ,  runtime.convI2I   -  Lgo.string."too many layers of packets"   .  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   .  type.error   .  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   /  runtime.convT2I   1  ("".readSignedMessage   3 (runtime.writeBarrier   3  .runtime.writebarrierptr   4   type.[]io.Reader   4  "runtime.growslice   5 (runtime.writeBarrier   5  .runtime.writebarrierptr   6  .runtime.writebarrierptr   9  tgolang.org/x/crypto/openpgp/packet.(*EncryptedKey).Decrypt   :  golang.org/x/crypto/openpgp/packet.(*SymmetricallyEncrypted).Decrypt   ;  dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   <  dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   < dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   <  runtime.ifaceeq   =  type."".Key   =  (runtime.typedmemmove   ?  2runtime.slicebytetostring   @  (type.map[string]bool   A  4runtime.mapaccess1_faststr   C  type."".Key   C  (runtime.typedmemmove   D  (type.map[string]bool   E  $runtime.mapassign1   E  type.[]"".Key   F  "runtime.growslice   H  ftype.*golang.org/x/crypto/openpgp/packet.Compressed   H  jtype.*golang.org/x/crypto/openpgp/packet.EncryptedKey   K       Q  .type."".keyEnvelopePair   R  (runtime.typedmemmove   R  2type.[]"".keyEnvelopePair   R  "runtime.growslice   T       U  type.[]uint64   U  "runtime.growslice   V (runtime.writeBarrier   W  .runtime.writebarrierptr   X  rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature   Y  .runtime.writebarrierptr   Y  .runtime.writebarrierptr   Y  0runtime.morestack_noctxt     "".autotmp_0307  type.error "".autotmp_0306 type.io.Reader "".autotmp_0304 ~type.**golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".autotmp_0303 type.int "".autotmp_0302  type.int "".autotmp_0301  type.error "".autotmp_0300  type.error "".autotmp_0299  type."".Key "".autotmp_0298 .type."".keyEnvelopePair "".autotmp_0297 0type.*"".keyEnvelopePair "".autotmp_0296  type.int "".autotmp_0295  type.int "".autotmp_0294 6type.map.bucket[string]bool "".autotmp_0293 0type.map.hdr[string]bool "".autotmp_0292 type.error "".autotmp_0291 .type."".keyEnvelopePair "".autotmp_0290 type."".Key "".autotmp_0289 type.*"".Key "".autotmp_0288 type.int "".autotmp_0287 type.int "".autotmp_0285 type.uint64 "".autotmp_0282 \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0280  type.[]io.Reader "".autotmp_0279 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0278  ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0277  type.error "".autotmp_0276  .type.*"".MessageDetails "".autotmp_0275  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0274  type.int "".autotmp_0273 type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".autotmp_0272  type.int "".autotmp_0271  type.int "".autotmp_0270  type.int "".autotmp_0269  type.int "".autotmp_0268 type.bool "".autotmp_0267 
type.string "".autotmp_0266  type.bool "".autotmp_0265 
type.string "".autotmp_0264 type.[]uint8 "".autotmp_0263  type.int "".autotmp_0262 type.int "".autotmp_0261 2type.[]"".keyEnvelopePair "".autotmp_0260  type.error "".autotmp_0258 
ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0257  type.int "".autotmp_0256  type.int "".autotmp_0255 type.[]"".Key Rgolang.org/x/crypto/openpgp/packet.err·1 type.error Xgolang.org/x/crypto/openpgp/packet.reader·3 type.io.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 type.io.Reader "".err type.error "".err type.error "".key type.[]uint8 "".err type.error "".passphrase 	type.[]uint8 "".fpr type.string 
"".pk .type."".keyEnvelopePair 0"".candidateFingerprints (type.map[string]bool "".decrypted $type.io.ReadCloser "".candidates type.[]"".Key "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".k type."".Key "".keys type.[]"".Key "".p jtype.*golang.org/x/crypto/openpgp/packet.EncryptedKey "".p |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader 
"".se ~type.*golang.org/x/crypto/openpgp/packet.SymmetricallyEncrypted "".pubKeys 	2type.[]"".keyEnvelopePair "".symKeys 
type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".err ptype.error 
"".md `.type.*"".MessageDetails "".config P^type.*golang.org/x/crypto/openpgp/packet.Config "".prompt @,type."".PromptFunction "".keyring  type."".KeyRing "".r  type.io.Reader "@f - 6-4kc9A>V804:22$VqPb3$g!
$Y+N4XWlYY10V'_A

)V14=  *(lA>&Wo3)&\+PQY)=^}+. Tgclocals·073d2fd56d13eddb795b325d75824174 Tgclocals·b6f672fdddf10a7b5843f603a95ac87a   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/read.go("".readSignedMessage  #  #dH%    H$HH;A  H8  H$H  11H$h  H$p  1H9uH    H$    HD$H$H  H$`  1H$   H$   1H$   H$   1H\$pH\$xH$@  H$    HL$HD$HT$H\$ H$p  H$h  H tHǄ$`      H8  H$   H$   H$   H$H$   HD$    L$`  H$   H$   D$=jq%-  H1H9tH[H-    H9w  HH      I   =       IP`IXX1H9  H    H$    HD$HD$`H   H$@  =     p  H(H$   HhH$   =     0  HhHl$pHhHl$x=        Hh H    H$`  =        Hh(HD$`H    1H9tfHL$`H$`  H tOH$   HChH$   =     uHKp1H$h  H$p  H8  LCpL$HL$    ҉H    H$H    H\$H    H\$    HD$hL@(L$Hl$    HD$`9 L@ L$Hl$    HD$`L@L$Hl$    HD$`H$Hl$    HD$`{ \I   H    1LD$hH    1H9tMHL$hI t=H$   I@hH$   =     u	IHpM@pL$HL$    A H    H$H    H\$H    H\$    L$`  HD$yIh`H t'H] M@hLD$H\$H    H$    DE M@`L$HT$    L$`  'A = ^=  H1H9tH[H-    H96  HH      H$@  H   H)H$   HiH$   1H$   H$   Hj H    H    H$  HǄ$     H    H$H    H\$H    H\$H$  H\$HD$         HL$(HD$0H$   H$   H$   H$   H$   H$   H HǄ$`      H$h  H$p  H8  HHT$HHRHC HK(HHH9wOHk HHHkHH$   H+H$   =     uHk1HXLCL$Hl$    H    H$HT$HD$HL$Hl$     HT$(HD$0HL$8H\$HH tKHHD$@HHk HK(HT$X=     u	HSMLCL$HT$    HT$XHD$@,뱉=֤H1H9tH[H-    H9  HH    X     H    H$   HǄ$     H    H$H    H\$H    H\$H$   H\$HD$         HL$(HD$0HǄ$`      H$h  H$p  H8  HhH,$HD$P(@l$    H$`  HD$PH\$H$   H\$H$   H\$ H\$pH\$(H\$xHL$0H\$8H$p  H$h  H tHǄ$`      H8  H   @jHHhHjPHhHl$D$H$X  H$H$P  H[0HT$H$   HD$ H\$(H$0  H$(  H ~HH$`  H t6H v)=     u	HSX LCXL$HT$        111111    t
        ,type."".MessageDetails     "runtime.newobject     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     $runtime.ifacethash     htype.*golang.org/x/crypto/openpgp/packet.LiteralData    (runtime.writeBarrier     8type."".signatureCheckReader     "runtime.newobject    (runtime.writeBarrier    (runtime.writeBarrier    (runtime.writeBarrier    (runtime.writeBarrier   	  Tgo.itab.*"".signatureCheckReader.io.Reader   	 (runtime.writeBarrier   
  .runtime.writebarrierptr   
  :type.*"".signatureCheckReader     type.io.Reader     Tgo.itab.*"".signatureCheckReader.io.Reader      runtime.typ2Itab     .runtime.writebarrierptr     .runtime.writebarrierptr     .runtime.writebarrierptr     .runtime.writebarrierptr     @go.itab."".checkReader.io.Reader    (runtime.writeBarrier     .runtime.writebarrierptr     &type."".checkReader     type.io.Reader     @go.itab."".checkReader.io.Reader      runtime.typ2Itab     type.io.Reader     (runtime.typedmemmove     .runtime.writebarrierptr     ftype.*golang.org/x/crypto/openpgp/packet.Compressed     Lgo.string."too many layers of packets"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I    (runtime.writeBarrier     .runtime.writebarrierptr      type.[]io.Reader     "runtime.growslice    (runtime.writeBarrier     .runtime.writebarrierptr     rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature     :go.string."nested signatures"     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error     runtime.convT2I     &"".hashForSignature   !       " (runtime.writeBarrier   "  .runtime.writebarrierptr   "  $runtime.panicindex   #  0runtime.morestack_noctxt   p  0"".autotmp_0339  type.*uint8 "".autotmp_0337 :type.*"".signatureCheckReader "".autotmp_0336  type.error "".autotmp_0335 type.error "".autotmp_0332 \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0331 &type."".checkReader "".autotmp_0330  :type.*"".signatureCheckReader "".autotmp_0329  type.int "".autotmp_0328 optype.golang.org/x/crypto/openpgp/errors.UnsupportedError "".autotmp_0327 Ontype.golang.org/x/crypto/openpgp/errors.StructuralError Rgolang.org/x/crypto/openpgp/packet.err·1 type.error Xgolang.org/x/crypto/openpgp/packet.reader·3 type.io.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".keys /type.[]"".Key "".p rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature "".err type.error "".wrappedHash type.hash.Hash "".h type.hash.Hash "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".err Ptype.error 
"".md @.type.*"".MessageDetails "".keyring  type."".KeyRing "".mdin .type.*"".MessageDetails "".packets  ^type.*golang.org/x/crypto/openpgp/packet.Reader Z"  >-.
A
	
	?,
	-<$<gG!/0/0/ b PVl
.[z2>	&VHl? Tgclocals·32b59a2f714914dd65254a6ea209e9bc Tgclocals·5532e819bd29530b183fefa3baac8db4   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/read.go&"".hashForSignature    dH%    HD$H;A  H   H$   1H$   H$   1H$   H$   1H$   H$   Hm  H    L    L9O  HH1H9<    H$    HL$HD$H$    H    H\$HD$   H$   HL$H$   HD$     H\$(H\$pH\$0H\$x1H$   H$   1H$   H$   H    H$H    H\$H    H\$H\$pH\$HD$         H\$(H$   H\$0H$   HĐ   H$    $   HT$HT$PHL$HL$X@ u:H$   H$   H$   H$   1H$   H$   HĐ   @   HT$`HL$h1H\$@H\$HH    H$    HD$HD$8Hl$`H(Hl$h=        HhH@    HD$8H    1H9tIHL$8H\$PH$   H\$XH$   H$   H$   1H$   H$   HĐ   H    H$H    H\$H    H\$    HD$L@L$Hl$    HD$8Q@H$    HL$HD$H$    H    H\$HD$   H$   HL$H$   HD$     H\$(H\$pH\$0H\$x1H$   H$   1H$   H$   H    H$H    H\$H    H\$H\$pH\$HD$         H\$(H$   H\$0H$   HĐ       1    :
        crypto.hashes    crypto.hashes     strconv.Itoa     @go.string."hash not available: "     *runtime.concatstring2     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error     runtime.convT2I     crypto.Hash.New     2type."".canonicalTextHash     "runtime.newobject    (runtime.writeBarrier   	  Ngo.itab.*"".canonicalTextHash.hash.Hash   
  4type.*"".canonicalTextHash   
  type.hash.Hash   
  Ngo.itab.*"".canonicalTextHash.hash.Hash   
   runtime.typ2Itab     .runtime.writebarrierptr     strconv.Itoa     Pgo.string."unsupported signature type: "     *runtime.concatstring2     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error     runtime.convT2I     $runtime.panicindex     0runtime.morestack_noctxt     "".autotmp_0354 4type.*"".canonicalTextHash "".autotmp_0351  ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError "".autotmp_0350  type.string "".autotmp_0349  4type.*"".canonicalTextHash "".autotmp_0348 ?ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError "".autotmp_0347 type.string "".~r1 type.hash.Hash "".h _type.hash.Hash "".h type.hash.Hash "".~r4 `type.error "".~r3 @type.hash.Hash "".~r2  type.hash.Hash "".sigType jtype.golang.org/x/crypto/openpgp/packet.SignatureType "".hashId   type.crypto.Hash Hd  6]8%:
 0 +0'# Tgclocals·4c20d8bae4de54c24b0d8e9d5a7507ea Tgclocals·75b04d23becfbadc005b25375f880226   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/read.go&"".checkReader.Read    dH%    H;a&  HX11H$   H$   H\$`Hk`H    HM HE(H\$hH\$H\$pH\$H\$xH\$HD$PH$HL$HHY H\$ H$   HD$(HL$0H$   H$   H-    H9u}H$HL$H-    Hl$H-    Hl$    \$  tMH\$`H tGH   H   Hl$@H,$HL$8HY HD$HL$H tH$   H$   HXÉ뵉E     
               io.EOF     io.EOF    io.EOF     runtime.ifaceeq            0runtime.morestack_noctxt   p  "".err Ptype.error "".n @type.int "".buf type.[]uint8 
"".cr  &type."".checkReader    ,+lD7	  vV Tgclocals·8cf14f50ac1bf7ae2848fda35f0590ec Tgclocals·64ca935d1a2110a30e2d604686188539   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/read.go>"".(*signatureCheckReader).Read    dH%    HD$H;A  H   11H$   H$   H$   Hk(H]`H W  HK Hk(H$   H\$H$   H\$H$   H\$Hl$xH,$HL$pHY HD$ H\$(H$   H\$0H$   H$   H$   H9  L$   H$   HH   HKHk L$   LD$H$   HD$H$   Ht$Hl$hH,$HL$`HY@H$   H-    H9  H$H$   Hl$H-    Hl$H-    Hl$    \$    1H\$@H\$HH$   H+H,$    H$   H\$H\$@H\$H\$HHL$HD$ Hj(H   H$   HMxH$   =     {  H   Hj(H]xH tHĸ   H\$@1H9tH[H-    H92  HD$HD$?Hj(H   =       H   |$?    H    H$   HǄ$   %   H    H$H    H\$H    H\$H$   H\$HD$         HL$(HD$0H$   Hk(H tCH$   HMxH$   =     uH   Hĸ   L   L$HD$    E HZ(H[XHkH,$HZH|$HHHKHOHZ(H   Hl$    H$   HL$ HD$(Hj(H    H$   HMxH$   =     uqH   Hj(H   H tLHj(H tJH   H   HD$XH$HL$PHY HD$HL$H tH$   H$   Hĸ   ÉE L   L$HD$    H$   tE HL   L$HD$    H$   E 1D$? L   L$HD$    H$   jE :H        K4
                      io.EOF     io.EOF    io.EOF     runtime.ifaceeq     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next    (runtime.writeBarrier     dtype.*golang.org/x/crypto/openpgp/packet.Signature   	 (runtime.writeBarrier   	  bgo.string."LiteralData not followed by Signature"   
  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   
  type.error   
  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   
  runtime.convT2I    (runtime.writeBarrier     .runtime.writebarrierptr     ~golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifySignature    (runtime.writeBarrier            .runtime.writebarrierptr     .runtime.writebarrierptr     .runtime.writebarrierptr     $runtime.panicslice     0runtime.morestack_noctxt   p  "".autotmp_0364 otype.error "".autotmp_0363  type.error "".autotmp_0362 Ontype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0360 /type.[]uint8 
"".ok type.bool "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".err Ptype.error "".n @type.int "".buf type.[]uint8 "".scr  :type.*"".signatureCheckReader > 	 3|LpW
6
		6 ( !# Tgclocals·92f44d26a99b4c9d566f716ef2d7d481 Tgclocals·28f56ac6bf6aee59936dfc37dc2ed818   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/read.go2"".CheckDetachedSignature  &  &dH%    H$H;AP	  H  11H$  H$  1H$  H$   H$(  1H$   H$   H$  H$   H$   H$   1H$  H$  H$  H$  H$  H$  H$  HD$p1H(HhHhH    H$    HD$H w  HǄ$8     HǄ$@     H$0  H$   H(H$   =       HhH\$pHCH$8  Hk H$@  Hk(H\$pH\$`H\$`H$    H\$H$   H\$H$   HL$HD$ H$  H-    H9urH$  H$HD$H-    Hl$H-    Hl$    H$  \$  t2H    H    HǄ$      H$  H$  H  H$  H tHǄ$      H  H$   H$   H$   H$H$   HD$    H$   H$   T$!  H1H9tH[H-    H9  HH      HH Hh0Hl$H(@l$GHL$D$H$  H$H$  H[0H\$H$  HL$ H\$(H$(  H$   H =H u]H    H$   HǄ$      H    H$H$   H\$HD$        H\$HH$HKHL$    H\$HH$\$G\$    H\$H$   H\$H$   HL$ HD$(HT$0H\$8H$  H$  H tHǄ$      H  H    H$HL$xHL$H$   HD$    H\$HH$HKHL$H$  H\$H$  H\$    HD$(HL$0H$   H$   H tTH-    H9  H$HL$H-    Hl$H-    Hl$    H$   H$   \$    H$  H$   H$(  H$X  1H$P  HD$PH$H  HHl$PH9{  HD$hH c  H8HpHPHhHL$XH$  H$`  H$  H$h  H$  H$p  H$  H$x  H$   H$   H$   H$H$   HD$    L$   L$   L$h  H$   H$   T$   H1H9tH[H-    H9  HH       L$LT$LL$HD$    HD$ H\$(H$  H$  H u*H$`  H$  1H$  H$  H  HD$hHL$XH HHl$PH9HǄ$      H  ÁYu\H1H9tH[H-    H9   HH    t/L$LT$LL$HD$    HD$ H\$(H$  1H$   H$   H    H$   HǄ$      H    H$H$   H\$HD$        H\$HH$HKHL$    11V11 HǄ$      H$  H$  H  ÁY   H1H9tH[H-    H9d  HH       HX  1H9   H    H$  HǄ$      H    H$H    H\$H    H\$H$  H\$HD$         HL$(HD$0HǄ$      H$  H$  H  HX  HM HhHl$H(@l$G.H$   H$   H    H$  HǄ$     H    H$H    H\$H    H\$H$  H\$HD$         HL$(HD$0HǄ$      H$  H$  H  1111gL@L$Hl$    H$0       `
        "type.[1]io.Reader     "runtime.newobject    (runtime.writeBarrier     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     fgolang.org/x/crypto/openpgp/errors.ErrUnknownIssuer    fgolang.org/x/crypto/openpgp/errors.ErrUnknownIssuer   	  $runtime.ifacethash   
  htype.*golang.org/x/crypto/openpgp/packet.SignatureV3            .go.string."unreachable"     type.string     runtime.convT2E     runtime.gopanic     &"".hashForSignature     type.io.Writer     runtime.convI2I     io.Copy     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     $runtime.ifacethash     htype.*golang.org/x/crypto/openpgp/packet.SignatureV3     golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifySignatureV3     dtype.*golang.org/x/crypto/openpgp/packet.Signature     ~golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifySignature     .go.string."unreachable"     type.string     runtime.convT2E     runtime.gopanic     dtype.*golang.org/x/crypto/openpgp/packet.Signature     Xgo.string."signature doesn't have an issuer"      ntype.golang.org/x/crypto/openpgp/errors.StructuralError      type.error      go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   !  runtime.convT2I   "  Lgo.string."non signature packet found"   #  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   #  type.error   #  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   $  runtime.convT2I   %  .runtime.writebarrierptr   %  0runtime.morestack_noctxt     L"".autotmp_0393  type.uint32 "".autotmp_0392  type.bool "".autotmp_0391  \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0390 type."".Key "".autotmp_0389 type.*"".Key "".autotmp_0388 type.int "".autotmp_0387  type.int "".autotmp_0386  type.error "".autotmp_0385  type.error "".autotmp_0382 \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0379  type.[]io.Reader "".autotmp_0378 _\type.golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0377 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0376  ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0375  type.string "".autotmp_0374 type.[]"".Key "".autotmp_0373 type.string "".autotmp_0372  type.int "".autotmp_0371 type.int "".autotmp_0370  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0369 ntype.golang.org/x/crypto/openpgp/errors.StructuralError Ngolang.org/x/crypto/openpgp/packet.r·2 type.io.Reader "".sig \type.golang.org/x/crypto/openpgp/packet.Packet "".key type."".Key "".err type.error "".wrappedHash type.hash.Hash "".h type.hash.Hash "".sig \type.golang.org/x/crypto/openpgp/packet.Packet "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".keys type.[]"".Key "".sigType jtype.golang.org/x/crypto/openpgp/packet.SignatureType "".hashFunc  type.crypto.Hash "".err ptype.error "".signer `type.*"".Entity "".signature @type.io.Reader "".signed  type.io.Reader "".keyring  type."".KeyRing ~"!28  6:L2	
C
]M*
*5*]$?=	& R fu3	. Tgclocals·33353b89c8d716aa30f1cbcff483ff29 Tgclocals·510abbe02d5ba0858c7154a80d9fec44   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/read.go@"".CheckArmoredDetachedSignature    dH%    H;a   HX11H$   H$   HǄ$       H$   H$H$   H\$H    H\$H    H\$    HL$ HD$(HT$0H\$8H$   H$   H tHXH\$`H$H\$hH\$H\$pH\$H\$xH\$HL$HHL$ HD$PHD$(    HT$0HL$8HD$@H$   H$   H$   HX    
         "".SignatureType     "".SignatureType     "".readArmored     2"".CheckDetachedSignature     0runtime.morestack_noctxt     "".body type.io.Reader "".err ptype.error "".signer `type.*"".Entity "".signature @type.io.Reader "".signed  type.io.Reader "".keyring  type."".KeyRing  k  7Rl  hoI Tgclocals·3a5692de2bcadad506bd8b6dd1491c00 Tgclocals·c55cf99de9cdd8c8202a466952fa1a45   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/read.go"".DetachSign    dH%    H;avzHH1H$   H$   H\$PH$H\$XH\$H\$`H\$H\$hH\$H\$pH\$ D$( H\$xH\$0    HL$8HD$@H$   H$   HH    m
        "".detachSign     0runtime.morestack_noctxt     
"".~r4 `type.error "".config P^type.*golang.org/x/crypto/openpgp/packet.Config "".message 0type.io.Reader "".signer  type.*"".Entity "".w  type.io.Writer u  0%d 
 e; Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go("".ArmoredDetachSign    dH%    H;av|HH11H$   H$   H\$PH$H\$XH\$H\$`H\$H\$hH\$H\$pH\$ D$( H\$xH\$0    HL$8HD$@H$   H$   HH    k
        ("".armoredDetachSign     0runtime.morestack_noctxt     
"".err `type.error "".config P^type.*golang.org/x/crypto/openpgp/packet.Config "".message 0type.io.Reader "".signer  type.*"".Entity "".w  type.io.Writer w  >'d 
 g9 Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go""".DetachSignText    dH%    H;avzHH1H$   H$   H\$PH$H\$XH\$H\$`H\$H\$hH\$H\$pH\$ D$(H\$xH\$0    HL$8HD$@H$   H$   HH    m
        "".detachSign     0runtime.morestack_noctxt     
"".~r4 `type.error "".config P^type.*golang.org/x/crypto/openpgp/packet.Config "".message 0type.io.Reader "".signer  type.*"".Entity "".w  type.io.Writer u  N%d 
 e; Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go0"".ArmoredDetachSignText    dH%    H;avzHH1H$   H$   H\$PH$H\$XH\$H\$`H\$H\$hH\$H\$pH\$ D$(H\$xH\$0    HL$8HD$@H$   H$   HH    m
        ("".armoredDetachSign     0runtime.morestack_noctxt     
"".~r4 `type.error "".config P^type.*golang.org/x/crypto/openpgp/packet.Config "".message 0type.io.Reader "".signer  type.*"".Entity "".w  type.io.Writer u  ^%d 
 e; Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go("".armoredDetachSign    dH%    H;aP  HX11H$   H$   H\$`H$H\$hH\$H    H\$H    H\$HD$         HL$(HD$0HT$8H\$@H$   H$   H tHXH    H$HL$HHL$HD$PHD$    H\$HH$HKHL$H\$pH\$H\$xH\$H$   H\$ $   \$(H$   H\$0    HD$8H\$@H$   H$   H tHXH\$PH$H\$HH[ HL$HD$H$   H$   HX    
         "".SignatureType     "".SignatureType     Pgolang.org/x/crypto/openpgp/armor.Encode     type.io.Writer     runtime.convI2I     "".detachSign            0runtime.morestack_noctxt     "".out &type.io.WriteCloser "".err ptype.error "".config `^type.*golang.org/x/crypto/openpgp/packet.Config "".sigType Pjtype.golang.org/x/crypto/openpgp/packet.SignatureType "".message 0type.io.Reader "".signer  type.*"".Entity "".w  type.io.Writer ,{2  (f+U3  _S. Tgclocals·236601f43b36f8c15cf70bb83f74cf9b Tgclocals·21a8f585a14d020f181242c5256583dc   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go"".detachSign    dH%    HD$H;A  H   H$   11H$   H$   HX1H9urH    H\$hHD$p&   H    H$H    H\$H    H\$H\$hH\$HD$         H\$(H$   H\$0H$   HĐ   Hh(   trH    H\$hHD$p   H    H$H    H\$H    H\$H\$hH\$HD$         H\$(H$   H\$0H$   HĐ   H    H$    H$   HL$$   @)L$   M@Ah@i1H9[  HZH M  HBHL$@HAH$    Ht$@HT$L$HD$H   HT$xHV0$   N8H$   =       HF@H   L$   IhH   HH=     l  HX  HnH,$.@l$    H\$H\$XH\$H\$`HL$ HD$(HT$0H\$8H$   H$   H tHĐ   H    H$HL$HHL$HD$PHD$    H\$HH$HKHL$H$   H\$H$   H\$    H\$@H$H\$XH\$H\$`H\$H$   HkHl$H$   H\$     HD$(H\$0H$   H$   H tHĐ   H\$@H$H$   H\$H$   H\$    HL$HD$ H$   H$   HĐ   LX  L$Hl$    Ht$@|E \?LF@L$HD$    Ht$@H       2
        dgo.string."signing key doesn't have a private key"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     Hgo.string."signing key is encrypted"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     btype.golang.org/x/crypto/openpgp/packet.Signature     "runtime.newobject     `golang.org/x/crypto/openpgp/packet.(*Config).Now    (runtime.writeBarrier    (runtime.writeBarrier     &"".hashForSignature   
  type.io.Writer   
  runtime.convI2I     io.Copy     hgolang.org/x/crypto/openpgp/packet.(*Signature).Sign     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize     .runtime.writebarrierptr     .runtime.writebarrierptr     0runtime.morestack_noctxt     "".autotmp_0403 /type.time.Time "".autotmp_0402  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0401 Oxtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".wrappedHash type.hash.Hash "".h otype.hash.Hash "".sig dtype.*golang.org/x/crypto/openpgp/packet.Signature "".err ptype.error "".config `^type.*golang.org/x/crypto/openpgp/packet.Config "".sigType Pjtype.golang.org/x/crypto/openpgp/packet.SignatureType "".message 0type.io.Reader "".signer  type.*"".Entity "".w  type.io.Writer VI]  n~;rr&R8EXRJ ( \tP7d Tgclocals·69607a593e43f6fa2bc465446e592f44 Tgclocals·1eb7b6f1914b2a4e4d031a73d90b819c   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go."".SymmetricallyEncrypt    dH%    HD$H;A  H   W$   $   $   111H$@  H$H  1H$0  H$8  H$   1H9uX1$   H$   H$   H$   $   H$   H$   1@(HhHhHhh Hh(H$   H$   H$H$   H\$H$  H\$H$  H\$H$  H\$ H$(  H\$(    H$(  Ht$0HT$8HL$@HD$HH\$PH$H  H$@  H tH   1H9G  _ :  oHH$   H$H$   H\$D$H$   Ht$H$   HT$ H$   HL$(H|$0    L$   H$(  Ht$8HT$@HD$HH\$PH$H  H$@  H tH   Ht$XIHt$hHT$`IHT$p1H9r  1H< t^11H9tHG0H4$HT$L$HD$    L$   LT$ LL$(HD$0H\$8H$H  H$@  H tH   1I    IHA@ $   Ih(H$   HL$xH     < u<I    IPAh $   Ih(H$   H$   H 	nHLT$hL$LL$pLL$A(@l$IXH|$HHHKHOT$(    Hl$0HT$8HL$@HD$HH$0  H$8  H$@  H$H  H   A N19A o(HH       >
        golang.org/x/crypto/openpgp/packet.SerializeSymmetricKeyEncrypted     golang.org/x/crypto/openpgp/packet.SerializeSymmetricallyEncrypted   	  lgolang.org/x/crypto/openpgp/packet.SerializeCompressed     fgolang.org/x/crypto/openpgp/packet.SerializeLiteral     0runtime.morestack_noctxt     "".autotmp_0408 _"type."".FileHints time.t·2 type.time.Time time.t·2 type.time.Time "".literaldata &type.io.WriteCloser "".w &type.io.WriteCloser "".key type.[]uint8 "".err type.error "".plaintext p&type.io.WriteCloser "".config `^type.*golang.org/x/crypto/openpgp/packet.Config "".hints P$type.*"".FileHints "".passphrase  type.[]uint8 "".ciphertext  type.io.Writer J/  nbX{;><x   Tgclocals·3bf9bfd9a4b2d2bcf5866321b663428f Tgclocals·ac8fc5e504bcdfad8f39318bb9fd05a2   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go."".intersectPreferences    dH%    H;a   L|$(Lt$0L\$LL$111H\$E1MMM9}7A)HHD$ 1ML9}(@8uAL9s5I<HIIM9|Hl$H9wLd$8H|$@Hl$H        HH    O
        $runtime.panicslice     $runtime.panicindex     0runtime.morestack_noctxt      "".autotmp_0422  type.uint8 "".autotmp_0414  type.[]uint8 "".autotmp_0413  type.int "".intersection `type.[]uint8 "".b 0type.[]uint8 "".a  type.[]uint8   4+!  / Tgclocals·a4452ddb8e4fb493d3c69dade262a1fa Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go"".hashToHashId    dH%    H;a   H8H\$@H$    \$H\$	 uTH    H\$(HD$0   H    H$H\$(H\$HD$        H\$HH$HKHL$    L$HH8    b
      B  Xgolang.org/x/crypto/openpgp/s2k.HashToHashId   t  Rgo.string."tried to convert unknown hash"     type.string     runtime.convT2E     runtime.gopanic     0runtime.morestack_noctxt    p  "".autotmp_0423 type.string "".~r1 type.uint8 "".h   type.crypto.Hash p|o  T		   J6 Tgclocals·c55cf99de9cdd8c8202a466952fa1a45 Tgclocals·d8fdd2a55187867c76648dc792366181   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go"".Encrypt  Z  ZdH%    H$H;A  H  W$  $  $  111H$P  H$X  1H$@  H$H  HǄ$       H$(  1H9a  H$8  H$    HT$L$HD$H$(  H$H$  HT$$  L$H$  HD$    H\$ H$   H\$(H$  HL$0H$  H\$8H$  \$@    H    H$  HǄ$     H    H$H    H\$H    H\$H$  H\$HD$         HL$(HD$01H$@  H$H  H$P  H$X  H  1H9   H    H$  HǄ$     H    H$H    H\$H    H\$H$  H\$HD$         HL$(HD$01H$@  H$H  H$P  H$X  H  H$   (      H    H$  HǄ$     H    H$H    H\$H    H\$H$  H\$HD$         HL$(HD$01H$@  H$H  H$P  H$X  H  H\$a-    @+-    @k-    @kHǄ$     HǄ$     H$  H$       \$\$`H$       \$\$_H$       \$\$^H$	       H$  \$H1ۈ\$d\$e\$f\$gH\$dH   H   H   l$`@+HHl$_@+HHl$^@+HHHHL$  HH9  L$  H)I)I tMH$x  L$  L$p  HHHH$  IH$  H95  H)I)IH$  I tMH$`  L$h  L$X  H$  H    H$HD$HD$    H\$H$@  H\$ H$H  H\$(H$P  H$  1H$   H$   H9  H$   HD$hH$8  H$    HT$L$HD$H$  Hl$hL$  L9E  HH+H,$H$  HT$$  L$H$  HD$    H\$ H$`  H\$(H$h  H\$0H$p  H\$8H$x  \$@\$[H$@  Hl$hL$H  L9  HHH$`  H\$Hl$H-    H,$    H$  HL$hH$  |$[   H9  HHHHkHH,$HD$       HL$HD$H$    H    H\$HD$#   H$  HL$H$  HD$ H    H\$(HD$0"       H\$8H$  H\$@H$  H    H$H    H\$H    H\$H$  H\$HD$         HL$(HD$01H$@  H$H  H$P  H$X  H      H9>  HH+H,$    H\$HKH   H  H  H   H   H$p  H$x  H$  HH   H(  H$(  H0  H8  H$8  H$0  H   H$X  H$(  H$`  H$0  H$h  H$8  H$  H$H$  H\$H$  H\$H$  H|$H$  HD$ H$   Ht$(    H\$0H$  H\$8H$  H\$@H$  H$  H$H$  H\$H$  H\$H$(  H\$H$0  H\$ H$8  H\$(    H\$0H$  H\$8H$  H\$@H$  H$   HH$   H9H$  H   H$  H   H$  H$   {  +@l$]H$8  1H9T  X G  hHHH$  H$  H$  1H9}(@8  @l$]HD$p    H$  H$  H$  H$  1H$  H$   H$  HH$   H9}lH$   (H$   @,$    HL$\$ W  Ho  H    L    L9Q  HH1H9<   HL$pH$8  1H9
  HXH 
  H@HD$xH
  H    L    L9
  HH1H9<    H$  H$  H$  H$  1H$  H$   H$  HH$   H9}BH$   (H$   @,$    HD$\$ 

  Hl$xH9	  HD$pH\$pH   H$  H$   t  +@l$\@,$    HT$H$  HL$H$   \$ ub\$\H$    HL$HD$H$   H$H    H\$HD$   H$  HL$H$  HD$     HT$(HL$0H$    H    H\$HD$L   H$  HT$H$   HL$ H    H\$(HD$0       H\$8H$  H\$@H$  H    H$H    H\$H    H\$H$  H\$HD$         HL$(HD$01H$@  H$H  H$P  H$X  H      \$]$    HD$H    H$HD$HD$    H|$Ht$ HT$(H$8  11H9  H(H   HH@H$   H$H$   HD$H$  H|$H$   Ht$H$  HT$     HD$0HL$8H$@  H$8  H t*1H$@  H$H  H$P  H$X  H  H$@  H$H  H$P  H$  1H$  H$   H$  HH$   H9>  HH$   H   H8H@HsHkH$   H$@  H$   H$H  H$P  H$0  H$X  H$8  H$   H$H$  H\$H$(  HD$\$]\$H$  H\$ H$   H\$(H$  H\$0H$8  H\$8    HD$@HL$HH$`  H$X  H t*1H$@  H$H  H$P  H$X  H  H$   H$   H HH$   H9H$   H$H$  H\$\$]\$H$  H\$H$   H\$ H$  H\$(H$8  H\$0    H$   H$0  LL$8Ht$@HD$HH\$PH$X  H$P  H tH  1H9  1$   H$   $   H$   $   H$     Hl$pHhi@hHiHHhH   @h H$   H    H$L$h  LL$H$p  Ht$    H\$H|$HHHKHOH$   H$    L$h  H$p  H$   H$0  HD$Hl$ H$P  H$H  H t*1H$@  H$H  H$P  H$X  H  1H9uX1҈$  H$  H$  H$  $  H$  H$  1@*HjHjHjj Hj(H$0  L$h  ML$  H$p  HH$  1H9   1H$  H$  H    H$LL$Ht$    H\$H$  HHM HKHMH    H$H    H\$H    H\$H$  H\$HD$         H$0  LD$(H|$01H   HrJ $  Hj(H$  H$  H     u;H p  HBj $  Hj(H$  H$  H 	nHL$  L$H$  H|$*@l$HZH|$HHHKHOD$(    H\$0H$(  H\$8H$0  HD$@H\$HH$X  H$P  H t1H$@  H$H  H  H$   1H9]  H\$pH$    H\$H$  H\$H$  H5    H$      HH$h  H$  H$p  H$  H$(  H$  H$0  H$  H\$pH$  H$  H$  H$  H$  H$   H$  H$8  H$  H    H$H    H\$H    H\$H$  H\$HD$         H\$(H$x  H\$0H$  H$x  H$@  H$  H$H  1H$P  H$X  H  H$(  H$@  H$0  H$H  1H$P  H$X  H  É1s: H    H    H$   HH$   H    1LH   H$   HH$   HR    1HHH       H    H$  HǄ$  @   H    H$H    H\$H    H\$H$  H\$HD$         HL$(HD$01H$@  H$H  H$P  H$X  H  5#                        W
        `golang.org/x/crypto/openpgp/packet.(*Config).Now     ."".(*Entity).signingKey     Bgo.string."no valid signing keys"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     Rgo.string."no private key in signing key"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I   	  Rgo.string."signing key must be decrypted"   	  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError   
  type.error   
  go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error   
  runtime.convT2I     """.statictmp_0459    """.statictmp_0459    """.statictmp_0459     "".hashToHashId     "".hashToHashId     "".hashToHashId     "".hashToHashId     type.[]"".Key     "runtime.makeslice     `golang.org/x/crypto/openpgp/packet.(*Config).Now     4"".(*Entity).encryptionKey     type."".Key     (runtime.typedmemmove     $strconv.FormatUint     ^go.string."cannot encrypt a message to key id "     \go.string." because it has no encryption keys"     *runtime.concatstring3     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     $runtime.panicindex     8"".(*Entity).primaryIdentity   !  ."".intersectPreferences   #  ."".intersectPreferences   (  Xgolang.org/x/crypto/openpgp/s2k.HashIdToHash   (  crypto.hashes   ) crypto.hashes   *  crypto.hashes   * crypto.hashes   ,  Xgolang.org/x/crypto/openpgp/s2k.HashIdToHash   .  \golang.org/x/crypto/openpgp/s2k.HashIdToString   /  strconv.Itoa   /  go.string."#"   0  *runtime.concatstring2   0  go.string."cannot encrypt because no candidate hash functions are compiled in. (Wanted "   1  6go.string." in this case.)"   1  *runtime.concatstring3   2  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError   2  type.error   2  go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error   2  runtime.convT2I   3  $runtime.panicindex   4  rgolang.org/x/crypto/openpgp/packet.CipherFunction.KeySize   4  type.[]uint8   4  "runtime.makeslice   6  io.ReadFull   <  pgolang.org/x/crypto/openpgp/packet.SerializeEncryptedKey   ?  golang.org/x/crypto/openpgp/packet.SerializeSymmetricallyEncrypted   B  type.io.Writer   B  runtime.convI2I   C  golang.org/x/crypto/openpgp/packet.(*OnePassSignature).Serialize   G  type.io.Writer   G  runtime.convI2I   H  $type."".noOpCloser   H  &type.io.WriteCloser   H  Hgo.itab."".noOpCloser.io.WriteCloser   I  runtime.convT2I   L  fgolang.org/x/crypto/openpgp/packet.SerializeLiteral   N  crypto.Hash.New   N  """.statictmp_0496   O  runtime.duffcopy   Q  .type."".signatureWriter   Q  &type.io.WriteCloser   Q  Rgo.itab."".signatureWriter.io.WriteCloser   R  runtime.convT2I   U  $crypto/rand.Reader   U $crypto/rand.Reader   U  $runtime.panicindex   V  $runtime.panicindex   W  $runtime.panicindex   W  go.string."cannot encrypt because recipient set shares no common algorithms"   W  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError   W  type.error   X  go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error   X  runtime.convT2I   Y  $runtime.panicindex   Y  $runtime.panicindex   Z  $runtime.panicindex   Z  $runtime.panicslice   Z  $runtime.panicslice   Z  0runtime.morestack_noctxt     "".autotmp_0497 	&type.io.WriteCloser "".autotmp_0494  type.bool "".autotmp_0493 "type."".FileHints "".autotmp_0491 ptype.golang.org/x/crypto/openpgp/packet.OnePassSignature "".autotmp_0489 type."".Key "".autotmp_0488 type.*"".Key "".autotmp_0487  type.int "".autotmp_0486  type.int "".autotmp_0485  type.error "".autotmp_0484 type.[32]uint8 "".autotmp_0483  type.uint8 "".autotmp_0482  type.*uint8 "".autotmp_0481  type.int "".autotmp_0480  type.int "".autotmp_0479  type.bool "".autotmp_0477  type.uint8 "".autotmp_0476  type.*uint8 "".autotmp_0475  type.int "".autotmp_0474  type.int "".autotmp_0473  type.uint8 "".autotmp_0472 type.*uint8 "".autotmp_0471  type.int "".autotmp_0470  type.int "".autotmp_0469  type.error "".autotmp_0468  type.error "".autotmp_0467 type."".Key "".autotmp_0466  type.int "".autotmp_0465  type.int "".autotmp_0464 type.[4]uint8 "".autotmp_0461 type.[3]uint8 "".autotmp_0458  type.error "".autotmp_0457  type.error "".autotmp_0455 .type."".signatureWriter "".autotmp_0454 	type.hash.Hash "".autotmp_0453 	$type."".noOpCloser "".autotmp_0452 type.[]"".Key "".autotmp_0451  type.int "".autotmp_0450  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0449  type.string "".autotmp_0448  type.[]uint8 "".autotmp_0447  type.[]uint8 "".autotmp_0446 type.[]uint8 "".autotmp_0445  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0444  type.int "".autotmp_0443  type.int "".autotmp_0442  type.int "".autotmp_0439  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0438 	type.string "".autotmp_0437  type.time.Time "".autotmp_0436  type.int "".autotmp_0435  type.int "".autotmp_0434  type.int "".autotmp_0433 type.int "".autotmp_0432 type.int "".autotmp_0430 type.uint8 "".autotmp_0429 type.uint8 "".autotmp_0428 type.uint8 "".autotmp_0427  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0426  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0425 xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0424 type.time.Time time.t·2 type.time.Time time.t·2 type.time.Time "".~r0 type.io.Reader "".literalData &type.io.WriteCloser "".w &type.io.WriteCloser "".err 
type.error "".ops rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature  "".encryptedData 
&type.io.WriteCloser "".err 
type.error "".key type."".Key "".err 
type.error "".symKey type.[]uint8 "".name type.string "".hashId type.uint8 """.configuredHash  type.crypto.Hash "".hash  type.crypto.Hash "".cipher ltype.golang.org/x/crypto/openpgp/packet.CipherFunction $"".preferredHashes type.[]uint8 *"".preferredSymmetric type.[]uint8 
"".ok type.bool "".i type.int "".encryptKeys type.[]"".Key  "".defaultHashes type.[]uint8 """.defaultCiphers type.[]uint8 $"".candidateHashes type.[]uint8 &"".candidateCiphers type.[]uint8 "".signKey type."".Key "".signer ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".err type.error "".plaintext &type.io.WriteCloser "".config p^type.*golang.org/x/crypto/openpgp/packet.Config "".hints `$type.*"".FileHints "".signed Ptype.*"".Entity 
"".to  "type.[]*"".Entity "".ciphertext  type.io.Writer "9B - e	E]JXI0"
20yy#*$*"	
	]Tb]*-b	;**(;*X&A;m:I#			-  h9y9)uQ; Tgclocals·79278f1b3c02451b235b26e0d050a9f3 Tgclocals·c9727f67d5b0f1d37117e6819cbd0215   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go0"".signatureWriter.Write    dH%    H;a   HX1H$   H$   H$   H$   H$   H\$H$   H\$H$   H\$HD$PH$HL$HHY@HL$pHD$xH$   H\$H$   H\$H$   H\$HD$@H$HL$8HY(HT$ HL$(HD$0H$   H$   H$   HX    
                      0runtime.morestack_noctxt     "".~r2 type.error "".~r1 type.int "".data type.[]uint8 "".s  .type."".signatureWriter   )Kq 
 r~ Tgclocals·d9f9402b3f7d1c398b577a45048cc887 Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go0"".signatureWriter.Close    dH%    HD$H;A  H   1H$   H$   H$   H$    H\$H$   \$$   H\$H$   H    H$    HD$HH |  WH      L$   M@8Ah@hH$   HhHD$@H$   Hh0$   h8H$   =        Hh@H   H$   H   HH=       HX  HD$8H$H$   H|$HHHKHOH$   H\$H$   H\$     HD$(HL$0HL$PHD$HH tH$   H$   HĠ   H$   H$   H$   H$HL$xHY HD$HL$HL$pHD$hH tH$   H$   HĠ   H    H$H$   H|$HHHKHO    H\$H|$HHHKHOH\$8H$    HD$HL$ HL$`HD$XH tH$   H$   HĠ   H$   H$   H$   H$HL$xHY HL$HD$H$   H$   HĠ   LX  L$Hl$    HD$@GE ' L@@L$Hl$    HD$@ }     
      |  `golang.org/x/crypto/openpgp/packet.(*Config).Now     btype.golang.org/x/crypto/openpgp/packet.Signature     "runtime.newobject     runtime.duffzero    (runtime.writeBarrier    (runtime.writeBarrier     hgolang.org/x/crypto/openpgp/packet.(*Signature).Sign            type.io.Writer     runtime.convI2I     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize   
         .runtime.writebarrierptr     .runtime.writebarrierptr     0runtime.morestack_noctxt     "".autotmp_0504 dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0502 /type.time.Time "".err type.error "".err otype.error "".err type.error "".sig dtype.*golang.org/x/crypto/openpgp/packet.Signature "".~r0 type.error "".s  .type."".signatureWriter FXHQ  P1
61@4]AkI   =5U Tgclocals·5705c76a0bc7db77dc7faa07cb35699a Tgclocals·b7fd37cad28ae6f68313022af47b36b8   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go&"".noOpCloser.Write    dH%    H;av}HH11H$   H$   HL$PHD$XH\$`H\$H\$hH\$H\$pH\$HD$@H$HL$8HY HT$ HL$(HD$0HT$xH$   H$   HH    j
               0runtime.morestack_noctxt     "".err `type.error "".n Ptype.int "".data  type.[]uint8 "".c  $type."".noOpCloser x  'e 
 a? Tgclocals·dacebcad73eed5073009fd67170948d0 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go&"".noOpCloser.Close      11H\$H\$  @   "".~r0  type.error "".c  $type."".noOpCloser     Tgclocals·0ebb2d1da58c1b4224bf5a7b370d7578 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go"".init    dH%    H;avf     t    u                                                            $
      $  "".initdone·   <  "".initdone·   R  "runtime.throwinit   b "".initdone·   n  hash.init   x  crypto/rsa.init     io.init     time.init     Lgolang.org/x/crypto/openpgp/armor.init     Ngolang.org/x/crypto/openpgp/errors.init     Ngolang.org/x/crypto/openpgp/packet.init     crypto.init     $crypto/sha256.init     strconv.init     Hgolang.org/x/crypto/openpgp/s2k.init    "".initdone·     0runtime.morestack_noctxt          
 
 (X Tgclocals·33cdeccccebe80329f1fdbee7f5874cb Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/write.go>type..hash."".canonicalTextHash   dH%    H;avvH H\$(H$H<$ tYH\$0H\$    HD$H\$(H$H<$ t,H$HD$0HD$HD$       H\$H\$8H É%    ˉ%        q
      \  "runtime.interhash     runtime.memhash     0runtime.morestack_noctxt   0@  "".~r2  type.uintptr "".h type.uintptr "".p  4type.*"".canonicalTextHash @_?@?   
 -c Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go:type..eq."".canonicalTextHash   dH%    H;a   HHH\$XH    HHsH\$PH twHHSH9uaHD$(H$HT$0HT$HL$8HL$Ht$@Ht$    \$  t+Hl$PH]LD$XIhH9t
D$` HHD$`HHD$` HHÉ녉l    <
        runtime.ifaceeq     0runtime.morestack_noctxt   0  
"".autotmp_0512 ?type.hash.Hash "".autotmp_0511 type.hash.Hash "".~r2  type.bool "".q 4type.*"".canonicalTextHash "".p  4type.*"".canonicalTextHash 8		   
 ke Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go(type..hash.[8]string   dH%    H;avpH(HL$81HD$   Hl$H9}DHD$ H\$0H t>HHHH$HL$8HL$    HL$HD$ HHl$H9|HL$@H(É    w
        runtime.strhash     0runtime.morestack_noctxt   0P  
"".autotmp_0514 type.int "".autotmp_0513 type.int "".~r2  type.uintptr "".h type.uintptr "".p  type.*[8]string PgOPO   
 U; Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go$type..eq.[8]string   dH%    H;a   HX1HD$(   Hl$(H9   HD$0H\$`H    HHHH3HKH\$hH tvHHHHHCH9uVHt$HH4$HL$PHL$HT$8HT$HD$@HD$    \$  t HD$0HHl$(H9nD$pHXD$p HXÉ놉c    
         runtime.eqstring     0runtime.morestack_noctxt   0  "".autotmp_0518 ?type.string "".autotmp_0517 type.string "".autotmp_0516 _type.int "".autotmp_0515 Otype.int "".~r2  type.bool "".q type.*[8]string "".p  type.*[8]string ,	    S Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go2"".(*EntityList).KeysById    dH%    H;a   H8HY HtH|$@H9;uH#11H\$PH\$XH\$`H\$@1H9uEH    H$HD$   H    H\$HD$
   H    H\$ HD$(       Ht$@HH$HNHL$HNHL$H\$HH\$    HT$ HL$(HD$0HT$PHL$XHD$`H8    
        &go.string."openpgp"     ,go.string."EntityList"     (go.string."KeysById"     "runtime.panicwrap     ,"".EntityList.KeysById     0runtime.morestack_noctxt   Pp  "".keys  type.[]"".Key 
"".id type.uint64 ""..this  &type.*"".EntityList po    f Tgclocals·89fe65749ce0afc971c0982226501ff0 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated><"".(*EntityList).KeysByIdUsage    dH%    H;a   H@HY HtH|$HH9;uH#11H\$`H\$hH\$pH\$H1H9uEH    H$HD$   H    H\$HD$
   H    H\$ HD$(       Ht$HHH$HNHL$HNHL$H\$PH\$\$X\$     HT$(HL$0HD$8HT$`HL$hHD$pH@    
        &go.string."openpgp"     ,go.string."EntityList"     2go.string."KeysByIdUsage"     "runtime.panicwrap     6"".EntityList.KeysByIdUsage     0runtime.morestack_noctxt   `  "".keys 0type.[]"".Key  "".requiredUsage  type.uint8 
"".id type.uint64 ""..this  &type.*"".EntityList     v Tgclocals·6432f8c6a0d23fa7bee6c5d96f21a92a Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>>"".(*EntityList).DecryptionKeys    dH%    H;a   H0HY HtH|$8H9;uH#11H\$@H\$HH\$PH\$81H9uEH    H$HD$   H    H\$HD$
   H    H\$ HD$(       Ht$8HH$HNHL$HNHL$    HT$HL$ HD$(HT$@HL$HHD$PH0    
        &go.string."openpgp"     ,go.string."EntityList"     4go.string."DecryptionKeys"     "runtime.panicwrap     8"".EntityList.DecryptionKeys     0runtime.morestack_noctxt   @`  "".keys type.[]"".Key ""..this  &type.*"".EntityList `_    f Tgclocals·2fccd208efe70893f9ac8d682812ae72 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>.type..hash.[1]io.Reader   dH%    H;avpH(HL$81HD$   Hl$H9}DHD$ H\$0H t>HHHH$HL$8HL$    HL$HD$ HHl$H9|HL$@H(É    w
        "runtime.interhash     0runtime.morestack_noctxt   0P  
"".autotmp_0523 type.int "".autotmp_0522 type.int "".~r2  type.uintptr "".h type.uintptr "".p  $type.*[1]io.Reader PgOPO   
 U; Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go*type..eq.[1]io.Reader   dH%    H;a   HX1HD$(   Hl$(H9   HD$0H\$hH    HHHHHsH\$`H tvHHHHHSH9uVHD$8H$HT$@HT$HL$HHL$Ht$PHt$    \$  t HD$0HHl$(H9nD$pHXD$p HXÉ놉c    
        runtime.ifaceeq     0runtime.morestack_noctxt   0  "".autotmp_0527 ?type.io.Reader "".autotmp_0526 type.io.Reader "".autotmp_0525 _type.int "".autotmp_0524 Otype.int "".~r2  type.bool "".q $type.*[1]io.Reader "".p  $type.*[1]io.Reader ,	    S Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go2"".KeyRing.DecryptionKeys   dH%    H;avbH HY HtH|$(H9;uH#1H\$8H\$@H\$HH\$0H$H\$(H[ HT$HL$HD$HT$8HL$@HD$HH     
               0runtime.morestack_noctxt   P@  "".~r0  type.[]"".Key ""..this  type."".KeyRing @]?  
 
 L4 Tgclocals·1347047f6245a35b91e9a4f213167d52 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>&"".KeyRing.KeysById   dH%    H;avlH(HY HtH|$0H9;uH#1H\$HH\$PH\$XH\$@H\$H\$8H$H\$0H[(HT$HL$HD$ HT$HHL$PHD$XH(    {
               0runtime.morestack_noctxt   `P  "".~r1 0type.[]"".Key 
"".id  type.uint64 ""..this  type."".KeyRing PgO   
 V: Tgclocals·d98f60bd8519d0c68364b2a1d83af357 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>0"".KeyRing.KeysByIdUsage   dH%    H;avuH0HY HtH|$8H9;uH#1H\$XH\$`H\$hH\$HH\$\$P\$H\$@H$H\$8H[0HT$HL$ HD$(HT$XHL$`HD$hH0    r
               0runtime.morestack_noctxt   p`  "".~r2 @type.[]"".Key  "".requiredUsage 0type.uint8 
"".id  type.uint64 ""..this  type."".KeyRing `p_   
 _1 Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>Dtype..hash."".signatureCheckReader   dH%    H;a   H H\$(H$H<$    H\$0H\$HD$       HD$H\$(H$H<$    H$HD$0HD$    HD$H\$(H$H<$ t^H$HD$0HD$    HD$H\$(H$H<$ t,H$(HD$0HD$HD$       H\$H\$8H É%    ˉ%    뙉%    d%    '    
      ~  runtime.memhash     "runtime.interhash     "runtime.interhash     runtime.memhash     0runtime.morestack_noctxt   0@  "".~r2  type.uintptr "".h type.uintptr "".p  :type.*"".signatureCheckReader @?@*?    > Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go@type..eq."".signatureCheckReader   dH%    H;a%  HHHT$PHD$XHH(H9t
D$` HHHHHpHBHRH9   HD$(H$HT$0HT$HL$8HL$Ht$@Ht$    \$     H\$XH    HKHs H\$PH txHCHS H9uaHD$(H$HT$0HT$HL$8HL$Ht$@Ht$    \$  t+Hl$PH](LD$XIh(H9t
D$` HHD$`HHD$` HHÉ넉jD$` HH    
        runtime.ifaceeq     runtime.ifaceeq     0runtime.morestack_noctxt   0  "".autotmp_0534  type.hash.Hash "".autotmp_0533  type.hash.Hash "".autotmp_0532 ?type.hash.Hash "".autotmp_0531 type.hash.Hash "".~r2  type.bool "".q :type.*"".signatureCheckReader "".p  :type.*"".signatureCheckReader D		    v Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go,"".(*checkReader).Read   dH%    H;a   H8HY HtH|$@H9;uH#11H\$hH\$pH\$@1H9uEH    H$HD$   H    H\$HD$   H    H\$ HD$(       Ht$@HH$H\$HH\$H\$PH\$H\$XH\$    HT$ HL$(HD$0HT$`HL$hHD$pH8    
        &go.string."openpgp"     .go.string."checkReader"      go.string."Read"     "runtime.panicwrap     &"".checkReader.Read     0runtime.morestack_noctxt   pp  "".err Ptype.error "".n @type.int "".buf type.[]uint8 ""..this  (type.*"".checkReader po    k Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>.type..hash."".FileHints   dH%    H;a   H H\$(H$H<$    H\$0H\$HD$       HD$H\$(H$H<$ tUH$HD$0HD$    HD$H\$(H$H<$ t#H$HD$0HD$    H\$H\$8H É%    ԉ%    뢉%    i    4

      ~  runtime.memhash     runtime.strhash     (type..hash.time.Time     0runtime.morestack_noctxt   0@  "".~r2  type.uintptr "".h type.uintptr "".p  $type.*"".FileHints @?@?    > Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go*type..eq."".FileHints   dH%    H;a   HHHL$PHD$X(@8t
D$` HHHqHIHPH@H9   Ht$8H4$HL$@HL$HT$(HT$HD$0HD$    \$  t\HL$PH tMHD$XHH t:HHH(H9u!Yh9uHYHhH9u
D$`HHD$` HHÉ D$` HH    
         runtime.eqstring     0runtime.morestack_noctxt   0  
"".autotmp_0538 ?type.string "".autotmp_0537 type.string "".~r2  type.bool "".q $type.*"".FileHints "".p  $type.*"".FileHints 8	    v Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go,"".(*noOpCloser).Write   dH%    H;a   H@HY HtH|$HH9;uH#11H\$pH\$xH\$H1H9uEH    H$HD$   H    H\$HD$
   H    H\$ HD$(       Ht$HHH$HNHL$H\$PH\$H\$XH\$H\$`H\$     HT$(HL$0HD$8HT$hHL$pHD$xH@    
        &go.string."openpgp"     ,go.string."noOpCloser"     "go.string."Write"     "runtime.panicwrap     &"".noOpCloser.Write     0runtime.morestack_noctxt   p  "".err Ptype.error "".n @type.int "".data type.[]uint8 ""..this  &type.*"".noOpCloser     { Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>,"".(*noOpCloser).Close   dH%    H;a   H0HY HtH|$8H9;uH#1H\$81H9uEH    H$HD$   H    H\$HD$
   H    H\$ HD$(       H\$8H tH+Hk11HD$@HD$HH0É    M
      |  &go.string."openpgp"     ,go.string."noOpCloser"     "go.string."Close"     "runtime.panicwrap     0runtime.morestack_noctxt   0`  "".~r0 type.error ""..this  &type.*"".noOpCloser `_`_   
 yG Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>:type..hash."".signatureWriter   dH%    H;a*  H H\$(H$H<$   H\$0H\$    HD$H\$(H$H<$    H$HD$0HD$    HD$H\$(H$H<$    H$ HD$0HD$HD$       HD$H\$(H$H<$ t^H$(HD$0HD$    HD$H\$(H$H<$ t,H$8HD$0HD$HD$       H\$H\$8H É%    ˉ%    뙉%    [%    "%        
      l  "runtime.interhash     "runtime.interhash     runtime.memhash     "runtime.interhash     runtime.memhash     0runtime.morestack_noctxt   0@  "".~r2  type.uintptr "".h type.uintptr "".p  0type.*"".signatureWriter @?@6?    5 Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go6type..eq."".signatureWriter   dH%    H;a  HhH\$xH   HHsH\$pH   HHSH9  HD$HH$HT$PHT$HL$XHL$Ht$`Ht$    \$  ]  H\$xH G  HKHsH\$pH )  HCHSH9  HD$HH$HT$PHT$HL$XHL$Ht$`Ht$    HL$xHD$p\$     HX Hi H9tƄ$    HhHHI(Hs0HH@(HS0H9   HD$(H$HT$0HT$HL$8HL$Ht$@Ht$    HL$xHD$p\$  tAHX8Hi8H9tƄ$    HhHX@Hi@H9tƄ$    HhƄ$   HhƄ$    HhƄ$    HhÉƄ$    HhÉE(    

        runtime.ifaceeq     runtime.ifaceeq     runtime.ifaceeq     0runtime.morestack_noctxt   0  "".autotmp_0548 type.hash.Hash "".autotmp_0547 _type.hash.Hash "".autotmp_0546  &type.io.WriteCloser "".autotmp_0545  &type.io.WriteCloser "".autotmp_0544 ?&type.io.WriteCloser "".autotmp_0543 &type.io.WriteCloser "".~r2  type.bool "".q 0type.*"".signatureWriter "".p  0type.*"".signatureWriter hx    s Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·895d0569a38a56443b84805daa09d838   /home/safchain/code/gocode/src/github.com/redhat-cip/skydive/Godeps/_workspace/src/golang.org/x/crypto/openpgp/canonical_text.go6"".(*signatureWriter).Write   dH%    H;a   HxHY HtH$   H9;uH#1H$   H$   H$   1H9uEH    H$HD$   H    H\$HD$   H    H\$ HD$(       H$   H tbH    HH$   H\$HH$   H\$PH$   H\$X    HT$`HL$hHD$pH$   H$   H$   HxÉ    
        &go.string."openpgp"     6go.string."signatureWriter"     "go.string."Write"     "runtime.panicwrap     runtime.duffcopy     0"".signatureWriter.Write     0runtime.morestack_noctxt   p  "".~r2 Ptype.error "".~r1 @type.int "".data type.[]uint8 ""..this  0type.*"".signatureWriter       Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>6"".(*signatureWriter).Close   dH%    H;a   HXHY HtH|$`H9;uH#1H\$hH\$pH\$`1H9uEH    H$HD$   H    H\$HD$   H    H\$ HD$(       Ht$`H t(H    H    HL$HHD$PHL$hHD$pHXÉ    5
        &go.string."openpgp"     6go.string."signatureWriter"     "go.string."Close"     "runtime.panicwrap     runtime.duffcopy     0"".signatureWriter.Close     0runtime.morestack_noctxt   0  "".~r0 type.error ""..this  0type.*"".signatureWriter      M Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>>Ngo.itab.*"".canonicalTextHash.hash.Hash     Tgclocals·0c8aa8e80191a30eac23f1a218103f16                   Tgclocals·aefd16b155593f6f07980a05b297ad1f                  Tgclocals·fdec177485cbfa40ac91f85390ec1fea        	           Tgclocals·5cbd57cf8f9b35eac9551b20a42afe1f                  Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·87d20ce1b58390b294df80b886db78bf             Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·3f5c1f818fa7055d0400cecd34057162             Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·3f5c1f818fa7055d0400cecd34057162             Tgclocals·c00bf85eed6a8e40863dfe64526ae817                  Tgclocals·32bd5c6dc84e3e86dd35593b3922d3aa                  Tgclocals·b7b1f8b35d2c0319a0b6f6545db4c972 @  @   )                        Tgclocals·600ee7d67c9c8255d714010babcfa954 (  (   	   	   	   	    Tgclocals·fb243b290e3147d06831a4c3432e1bbf                  Tgclocals·49911706e77e6300db306d6db0912e94        	   	   	    Tgclocals·7f7e31e410d386547ddc0047dc2faa98 p  p   $                 
      
                     Tgclocals·0c238911198547350f64f1a5c3f6eaea @  @                         Tgclocals·f3cd884107c94d2b58adda1e0ef3f9dc 0  0                    Tgclocals·d89baa940c5dd9c3413a865661528d54 0  0         !      !    Tgclocals·1bcec613e24368dd337b6dd546e388e5 (  (               Tgclocals·6a5390a59b8d22a13b923714ec7f5cb9 (  (            	    >go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     Jgo.string.hdr."no armored data found"                       Bgo.string."no armored data found"   Bgo.string."no armored data found" 0  ,no armored data found  vgo.string.hdr."expected public or private key block, got: "             +          ngo.string."expected public or private key block, got: "   ngo.string."expected public or private key block, got: " `  Xexpected public or private key block, got:   Tgclocals·07c886799a88ac80d684b8bca7c92573 0  0                     Tgclocals·4c546aaa12bca0a07eec0d3ecf7c37e3 0  0                   Tgclocals·db08f305c468200e3cf791eda6a8ebaa @  @          $  $  a$  a$  c$   Tgclocals·1f1dd8e7d89cf8bf3d8c95fe792f66ad @  @                  g       6go.string.hdr."unreachable"                       .go.string."unreachable"   .go.string."unreachable"    unreachable  Tgclocals·51562c45243a0c5ce48841e15ba48784 8  8          0              Tgclocals·725f69b7ae8520ac59af51db7db265d1 8  8                      >go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     rgo.string.hdr."first packet was not a public/private key"             )          jgo.string."first packet was not a public/private key"   jgo.string."first packet was not a public/private key" `  Tfirst packet was not a public/private key  rgo.string.hdr."primary key cannot be used for signatures"             )          jgo.string."primary key cannot be used for signatures"   jgo.string."primary key cannot be used for signatures" `  Tprimary key cannot be used for signatures  zgo.string.hdr."user ID packet not followed by self-signature"             -          rgo.string."user ID packet not followed by self-signature"   rgo.string."user ID packet not followed by self-signature" `  \user ID packet not followed by self-signature  `go.string.hdr."user ID self-signature invalid: "                        Xgo.string."user ID self-signature invalid: "   Xgo.string."user ID self-signature invalid: " P  Buser ID self-signature invalid:   xgo.string.hdr."signature packet found before user id packet"             ,          pgo.string."signature packet found before user id packet"   pgo.string."signature packet found before user id packet" `  Zsignature packet found before user id packet  Zgo.string.hdr."entity without any identities"                       Rgo.string."entity without any identities"   Rgo.string."entity without any identities" @  <entity without any identities  xgo.string.hdr."revocation signature signed by alternate key"             ,          pgo.string."revocation signature signed by alternate key"   pgo.string."revocation signature signed by alternate key" `  Zrevocation signature signed by alternate key  Tgclocals·13f87cc0608ea5e3ee364165a76a979f      (                                                 0   00   0     2                                                                 	     0                   Tgclocals·59a081aa56aea3db12c49708a232e907                                                                                           Tgo.string.hdr."subkey signature invalid: "                       Lgo.string."subkey signature invalid: "   Lgo.string."subkey signature invalid: " @  6subkey signature invalid:   ngo.string.hdr."subkey packet not followed by signature"             '          fgo.string."subkey packet not followed by signature"   fgo.string."subkey packet not followed by signature" P  Psubkey packet not followed by signature  `go.string.hdr."subkey signature with wrong type"                        Xgo.string."subkey signature with wrong type"   Xgo.string."subkey signature with wrong type" P  Bsubkey signature with wrong type  Tgclocals·a3f332e265628a83ebf74125fa889474 8  8                      Tgclocals·cc66687e142fc5da495a1664db6f640f 8  8                      tgo.string.hdr."user id field contained invalid characters"             *          lgo.string."user id field contained invalid characters"   lgo.string."user id field contained invalid characters" `  Vuser id field contained invalid characters  Tgclocals·b23e7c8f52cf08edb06e25e1ada78141               @     @  @  @ @ @ @ E@ E@ E @  @ @ -@ =@ = @ - @  @  @ @       Tgclocals·092fba05dc9a1d750fd3f830d20d2ea3      
   U   U      U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U    Tgclocals·3ad51b90552f8e39bfd16e2811d6b9a2 8  8                    Tgclocals·cc66687e142fc5da495a1664db6f640f 8  8                      Tgclocals·bdba11b0e20d0b4a0d5c7fb1c5481022 @  @                     Tgclocals·b385d9a51ca4f468987863aa65654328 @  @                         lgo.string.hdr."signing Entity must have a private key"             &          dgo.string."signing Entity must have a private key"   dgo.string."signing Entity must have a private key" P  Nsigning Entity must have a private key  |go.string.hdr."signing Entity's private key must be decrypted"             .          tgo.string."signing Entity's private key must be decrypted"   tgo.string."signing Entity's private key must be decrypted" `  ^signing Entity's private key must be decrypted  rgo.string.hdr."given identity string not found in Entity"             )          jgo.string."given identity string not found in Entity"   jgo.string."given identity string not found in Entity" `  Tgiven identity string not found in Entity  Tgclocals·5162572c77809d4735df497e4a91f652 H  H                  
          Tgclocals·949580c181e84412df3073e61f463446 H  H                            4go.string.hdr."expected '"             
          ,go.string."expected '"   ,go.string."expected '"    expected '  0go.string.hdr."', got: "                       (go.string."', got: "   (go.string."', got: "    ', got:   Tgclocals·79d0667feac83fcec4421590bfc5b188 0  0                     Tgclocals·537385343e646e25b1b6fced99dbb969 0  0         7          |go.string.hdr."key material not followed by encrypted message"             .          tgo.string."key material not followed by encrypted message"   tgo.string."key material not followed by encrypted message" `  ^key material not followed by encrypted message  Tgo.string.hdr."too many layers of packets"                       Lgo.string."too many layers of packets"   Lgo.string."too many layers of packets" @  6too many layers of packets  Tgclocals·b6f672fdddf10a7b5843f603a95ac87a   !                       0   @          8   @             @            @             @             @            @         (              	    @      JI   @    JI  @    J           JI@  @    JI@  @   x  JI@  @      JI   A      J	   @      J	 @      J
            J           J
           J           J            J             J    @             @            @      >      @                                                                    Tgclocals·073d2fd56d13eddb795b325d75824174   !   	   ?   ?   ?   ?   ?   ?                                                        ?               ?   ?   ?   ?    >go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error     >Tgo.itab.*"".signatureCheckReader.io.Reader     >@go.itab."".checkReader.io.Reader     Bgo.string.hdr."nested signatures"                       :go.string."nested signatures"   :go.string."nested signatures" 0  $nested signatures  Tgclocals·5532e819bd29530b183fefa3baac8db4 x  x          `  `` h  h             `            Tgclocals·32b59a2f714914dd65254a6ea209e9bc x  x                                              Hgo.string.hdr."hash not available: "                       @go.string."hash not available: "   @go.string."hash not available: " 0  *hash not available:   Xgo.string.hdr."unsupported signature type: "                       Pgo.string."unsupported signature type: "   Pgo.string."unsupported signature type: " @  :unsupported signature type:   Tgclocals·75b04d23becfbadc005b25375f880226 0  0             x       Tgclocals·4c20d8bae4de54c24b0d8e9d5a7507ea 0  0          <            Tgclocals·64ca935d1a2110a30e2d604686188539                    Tgclocals·8cf14f50ac1bf7ae2848fda35f0590ec              c    jgo.string.hdr."LiteralData not followed by Signature"             %          bgo.string."LiteralData not followed by Signature"   bgo.string."LiteralData not followed by Signature" P  LLiteralData not followed by Signature  Tgclocals·28f56ac6bf6aee59936dfc37dc2ed818 0  0                     Tgclocals·92f44d26a99b4c9d566f716ef2d7d481 0  0         c   c   c    `go.string.hdr."signature doesn't have an issuer"                        Xgo.string."signature doesn't have an issuer"   Xgo.string."signature doesn't have an issuer" P  Bsignature doesn't have an issuer  Tgo.string.hdr."non signature packet found"                       Lgo.string."non signature packet found"   Lgo.string."non signature packet found" @  6non signature packet found  Tgclocals·510abbe02d5ba0858c7154a80d9fec44      .              	     	      	     	    	       	     	      	     	   x  	     	  x 	  x  	   Tgclocals·33353b89c8d716aa30f1cbcff483ff29      	   ?   ?   ?   ?     ?   ?   ?   ?   ?       ?   ?    Tgclocals·c55cf99de9cdd8c8202a466952fa1a45                    Tgclocals·3a5692de2bcadad506bd8b6dd1491c00        	   ?       Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·21a8f585a14d020f181242c5256583dc                   Tgclocals·236601f43b36f8c15cf70bb83f74cf9b        	   _   _    lgo.string.hdr."signing key doesn't have a private key"             &          dgo.string."signing key doesn't have a private key"   dgo.string."signing key doesn't have a private key" P  Nsigning key doesn't have a private key  Pgo.string.hdr."signing key is encrypted"                       Hgo.string."signing key is encrypted"   Hgo.string."signing key is encrypted" @  2signing key is encrypted  Tgclocals·1eb7b6f1914b2a4e4d031a73d90b819c 0  0   
                  Tgclocals·69607a593e43f6fa2bc465446e592f44 0  0   	   _   _   _   _    Tgclocals·ac8fc5e504bcdfad8f39318bb9fd05a2 (  (           @  @  Tgclocals·3bf9bfd9a4b2d2bcf5866321b663428f (  (      g     g    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·a4452ddb8e4fb493d3c69dade262a1fa      	   	    Zgo.string.hdr."tried to convert unknown hash"                       Rgo.string."tried to convert unknown hash"   Rgo.string."tried to convert unknown hash" @  <tried to convert unknown hash  Tgclocals·d8fdd2a55187867c76648dc792366181                   Tgclocals·c55cf99de9cdd8c8202a466952fa1a45                    >Hgo.itab."".noOpCloser.io.WriteCloser     >Rgo.itab."".signatureWriter.io.WriteCloser     Jgo.string.hdr."no valid signing keys"                       Bgo.string."no valid signing keys"   Bgo.string."no valid signing keys" 0  ,no valid signing keys  Zgo.string.hdr."no private key in signing key"                       Rgo.string."no private key in signing key"   Rgo.string."no private key in signing key" @  <no private key in signing key  Zgo.string.hdr."signing key must be decrypted"                       Rgo.string."signing key must be decrypted"   Rgo.string."signing key must be decrypted" @  <signing key must be decrypted  fgo.string.hdr."cannot encrypt a message to key id "             #          ^go.string."cannot encrypt a message to key id "   ^go.string."cannot encrypt a message to key id " P  Hcannot encrypt a message to key id   dgo.string.hdr." because it has no encryption keys"             "          \go.string." because it has no encryption keys"   \go.string." because it has no encryption keys" P  F because it has no encryption keys  go.string.hdr."cannot encrypt because recipient set shares no common algorithms"             @          go.string."cannot encrypt because recipient set shares no common algorithms"   go.string."cannot encrypt because recipient set shares no common algorithms"   cannot encrypt because recipient set shares no common algorithms  "go.string.hdr."#"                       go.string."#"   go.string."#"   #  go.string.hdr."cannot encrypt because no candidate hash functions are compiled in. (Wanted "             L          go.string."cannot encrypt because no candidate hash functions are compiled in. (Wanted "   go.string."cannot encrypt because no candidate hash functions are compiled in. (Wanted "   cannot encrypt because no candidate hash functions are compiled in. (Wanted   >go.string.hdr." in this case.)"                       6go.string." in this case.)"   6go.string." in this case.)"      in this case.)  Tgclocals·c9727f67d5b0f1d37117e6819cbd0215      d                             @             @            @         I  @         I  @              @        $I   @         	  @    	     @   @             @            @            @             @            @            @           @           @              @|    Tgclocals·79278f1b3c02451b235b26e0d050a9f3                                                        Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·d9f9402b3f7d1c398b577a45048cc887            Tgclocals·b7fd37cad28ae6f68313022af47b36b8 0  0                    Tgclocals·5705c76a0bc7db77dc7faa07cb35699a 0  0               Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·dacebcad73eed5073009fd67170948d0             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0ebb2d1da58c1b4224bf5a7b370d7578             Hgo.string.hdr."PGP PUBLIC KEY BLOCK"                       @go.string."PGP PUBLIC KEY BLOCK"   @go.string."PGP PUBLIC KEY BLOCK" 0  *PGP PUBLIC KEY BLOCK  Jgo.string.hdr."PGP PRIVATE KEY BLOCK"                       Bgo.string."PGP PRIVATE KEY BLOCK"   Bgo.string."PGP PRIVATE KEY BLOCK" 0  ,PGP PRIVATE KEY BLOCK  :go.string.hdr."PGP SIGNATURE"                       2go.string."PGP SIGNATURE"   2go.string."PGP SIGNATURE"    PGP SIGNATURE  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           <"".newline  0type.[]uint8 0                         """.statictmp_0510   < "".PublicKeyType   type.string                    @go.string."PGP PUBLIC KEY BLOCK"   <""".PrivateKeyType   type.string                    Bgo.string."PGP PRIVATE KEY BLOCK"   < "".SignatureType   type.string                    2go.string."PGP SIGNATURE"   """.statictmp_0459  type.[3]uint8 	 """.statictmp_0496  .type."".signatureWriter   >""".statictmp_0510  type.[2]uint8 
 >"".initdone·  type.uint8   4"".NewCanonicalTextHash·f              ."".NewCanonicalTextHash   @"".(*canonicalTextHash).Write·f              :"".(*canonicalTextHash).Write   <"".(*canonicalTextHash).Sum·f              6"".(*canonicalTextHash).Sum   @"".(*canonicalTextHash).Reset·f              :"".(*canonicalTextHash).Reset   >"".(*canonicalTextHash).Size·f              8"".(*canonicalTextHash).Size   H"".(*canonicalTextHash).BlockSize·f              B"".(*canonicalTextHash).BlockSize   >"".(*Entity).primaryIdentity·f              8"".(*Entity).primaryIdentity   :"".(*Entity).encryptionKey·f              4"".(*Entity).encryptionKey   4"".(*Entity).signingKey·f              ."".(*Entity).signingKey   2"".EntityList.KeysById·f              ,"".EntityList.KeysById   <"".EntityList.KeysByIdUsage·f              6"".EntityList.KeysByIdUsage   >"".EntityList.DecryptionKeys·f              8"".EntityList.DecryptionKeys   0"".ReadArmoredKeyRing·f              *"".ReadArmoredKeyRing   """.ReadKeyRing·f              "".ReadKeyRing   2"".readToNextPublicKey·f              ,"".readToNextPublicKey    "".ReadEntity·f              "".ReadEntity   "".addSubkey·f              "".addSubkey   "".NewEntity·f              "".NewEntity   @"".(*Entity).SerializePrivate·f              :"".(*Entity).SerializePrivate   2"".(*Entity).Serialize·f              ,"".(*Entity).Serialize   8"".(*Entity).SignIdentity·f              2"".(*Entity).SignIdentity   """.readArmored·f              "".readArmored   """.ReadMessage·f              "".ReadMessage   ."".readSignedMessage·f              ("".readSignedMessage   ,"".hashForSignature·f              &"".hashForSignature   ,"".checkReader.Read·f              &"".checkReader.Read   D"".(*signatureCheckReader).Read·f              >"".(*signatureCheckReader).Read   8"".CheckDetachedSignature·f              2"".CheckDetachedSignature   F"".CheckArmoredDetachedSignature·f              @"".CheckArmoredDetachedSignature    "".DetachSign·f              "".DetachSign   ."".ArmoredDetachSign·f              ("".ArmoredDetachSign   ("".DetachSignText·f              """.DetachSignText   6"".ArmoredDetachSignText·f              0"".ArmoredDetachSignText   ."".armoredDetachSign·f              ("".armoredDetachSign    "".detachSign·f              "".detachSign   4"".SymmetricallyEncrypt·f              ."".SymmetricallyEncrypt   4"".intersectPreferences·f              ."".intersectPreferences   $"".hashToHashId·f              "".hashToHashId   "".Encrypt·f              "".Encrypt   6"".signatureWriter.Write·f              0"".signatureWriter.Write   6"".signatureWriter.Close·f              0"".signatureWriter.Close   ,"".noOpCloser.Write·f              &"".noOpCloser.Write   ,"".noOpCloser.Close·f              &"".noOpCloser.Close   "".init·f              "".init   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             Ftype..hashfunc."".canonicalTextHash              >type..hash."".canonicalTextHash   Btype..eqfunc."".canonicalTextHash              :type..eq."".canonicalTextHash   <type..alg."".canonicalTextHash                        Ftype..hashfunc."".canonicalTextHash     Btype..eqfunc."".canonicalTextHash   "runtime.gcbits.01    Tgo.string.hdr."*openpgp.canonicalTextHash"                       Lgo.string."*openpgp.canonicalTextHash"   Lgo.string."*openpgp.canonicalTextHash" @  6*openpgp.canonicalTextHash  hgo.string.hdr."func(*openpgp.canonicalTextHash) int"             $          `go.string."func(*openpgp.canonicalTextHash) int"   `go.string."func(*openpgp.canonicalTextHash) int" P  Jfunc(*openpgp.canonicalTextHash) int  Htype.func(*"".canonicalTextHash) int                 $D[ 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  hgo.string.hdr."func(*openpgp.canonicalTextHash) int"   p  Zgo.weak.type.*func(*"".canonicalTextHash) int    Htype.func(*"".canonicalTextHash) int    Htype.func(*"".canonicalTextHash) int     4type.*"".canonicalTextHash     type.int   go.typelink.func(*openpgp.canonicalTextHash) int	func(*"".canonicalTextHash) int              Htype.func(*"".canonicalTextHash) int   `go.string.hdr."func(*openpgp.canonicalTextHash)"                        Xgo.string."func(*openpgp.canonicalTextHash)"   Xgo.string."func(*openpgp.canonicalTextHash)" P  Bfunc(*openpgp.canonicalTextHash)  @type.func(*"".canonicalTextHash)                 % 3                                                                                                      0  runtime.algarray   @  "runtime.gcbits.01   P  `go.string.hdr."func(*openpgp.canonicalTextHash)"   p  Rgo.weak.type.*func(*"".canonicalTextHash)    @type.func(*"".canonicalTextHash)    @type.func(*"".canonicalTextHash)     4type.*"".canonicalTextHash   go.typelink.func(*openpgp.canonicalTextHash)	func(*"".canonicalTextHash)              @type.func(*"".canonicalTextHash)   .go.string.hdr."[]uint8"                       &go.string."[]uint8"   &go.string."[]uint8"   []uint8  type.[]uint8                 ~.8                                                 
0  runtime.algarray   @  "runtime.gcbits.01   P  .go.string.hdr."[]uint8"   p  *go.weak.type.*[]uint8     type.uint8   6go.typelink.[]uint8	[]uint8              type.[]uint8   go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) []uint8"             1          zgo.string."func(*openpgp.canonicalTextHash, []uint8) []uint8"   zgo.string."func(*openpgp.canonicalTextHash, []uint8) []uint8" p  dfunc(*openpgp.canonicalTextHash, []uint8) []uint8  btype.func(*"".canonicalTextHash, []uint8) []uint8                 |# 3                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) []uint8"   p  tgo.weak.type.*func(*"".canonicalTextHash, []uint8) []uint8    btype.func(*"".canonicalTextHash, []uint8) []uint8    btype.func(*"".canonicalTextHash, []uint8) []uint8     4type.*"".canonicalTextHash     type.[]uint8     type.[]uint8   go.typelink.func(*openpgp.canonicalTextHash, []uint8) []uint8	func(*"".canonicalTextHash, []uint8) []uint8              btype.func(*"".canonicalTextHash, []uint8) []uint8   go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) (int, error)"             6          go.string."func(*openpgp.canonicalTextHash, []uint8) (int, error)"   go.string."func(*openpgp.canonicalTextHash, []uint8) (int, error)" p  nfunc(*openpgp.canonicalTextHash, []uint8) (int, error)  ltype.func(*"".canonicalTextHash, []uint8) (int, error)                 ^- 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) (int, error)"   p  ~go.weak.type.*func(*"".canonicalTextHash, []uint8) (int, error)    ltype.func(*"".canonicalTextHash, []uint8) (int, error)    ltype.func(*"".canonicalTextHash, []uint8) (int, error)     4type.*"".canonicalTextHash     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.canonicalTextHash, []uint8) (int, error)	func(*"".canonicalTextHash, []uint8) (int, error)              ltype.func(*"".canonicalTextHash, []uint8) (int, error)   2go.string.hdr."BlockSize"             	          *go.string."BlockSize"   *go.string."BlockSize"    BlockSize  4go.string.hdr."func() int"             
          ,go.string."func() int"   ,go.string."func() int"    func() int  type.func() int                 9 3                                                                                                      0  runtime.algarray   @  "runtime.gcbits.01   P  4go.string.hdr."func() int"   p  0go.weak.type.*func() int    type.func() int    type.func() int     type.int   Bgo.typelink.func() int	func() int              type.func() int   *go.string.hdr."Reset"                       "go.string."Reset"   "go.string."Reset"   Reset  ,go.string.hdr."func()"                       $go.string."func()"   $go.string."func()"   func()  type.func()                  3                                                                                                0  runtime.algarray   @  "runtime.gcbits.01   P  ,go.string.hdr."func()"   p  (go.weak.type.*func()    type.func()    type.func()   2go.typelink.func()	func()              type.func()   (go.string.hdr."Size"                        go.string."Size"    go.string."Size"   
Size  &go.string.hdr."Sum"                       go.string."Sum"   go.string."Sum"   Sum  Jgo.string.hdr."func([]uint8) []uint8"                       Bgo.string."func([]uint8) []uint8"   Bgo.string."func([]uint8) []uint8" 0  ,func([]uint8) []uint8  4type.func([]uint8) []uint8                 & 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  Jgo.string.hdr."func([]uint8) []uint8"   p  Fgo.weak.type.*func([]uint8) []uint8    4type.func([]uint8) []uint8    4type.func([]uint8) []uint8     type.[]uint8     type.[]uint8   ngo.typelink.func([]uint8) []uint8	func([]uint8) []uint8              4type.func([]uint8) []uint8   *go.string.hdr."Write"                       "go.string."Write"   "go.string."Write"   Write  Tgo.string.hdr."func([]uint8) (int, error)"                       Lgo.string."func([]uint8) (int, error)"   Lgo.string."func([]uint8) (int, error)" @  6func([]uint8) (int, error)  >type.func([]uint8) (int, error)                 N4P 3                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  Tgo.string.hdr."func([]uint8) (int, error)"   p  Pgo.weak.type.*func([]uint8) (int, error)    >type.func([]uint8) (int, error)    >type.func([]uint8) (int, error)     type.[]uint8     type.int     type.error   go.typelink.func([]uint8) (int, error)	func([]uint8) (int, error)              >type.func([]uint8) (int, error)   4type.*"".canonicalTextHash                  -	} 6                                                                                                                                                                                                                                                                                                                                      @0  runtime.algarray   @  "runtime.gcbits.01   P  Tgo.string.hdr."*openpgp.canonicalTextHash"   p  Fgo.weak.type.**"".canonicalTextHash     2type."".canonicalTextHash   ` 4type.*"".canonicalTextHash    4type.*"".canonicalTextHash     2go.string.hdr."BlockSize"     type.func() int     Htype.func(*"".canonicalTextHash) int     B"".(*canonicalTextHash).BlockSize     B"".(*canonicalTextHash).BlockSize     *go.string.hdr."Reset"     type.func()     @type.func(*"".canonicalTextHash)     :"".(*canonicalTextHash).Reset     :"".(*canonicalTextHash).Reset     (go.string.hdr."Size"     type.func() int     Htype.func(*"".canonicalTextHash) int     8"".(*canonicalTextHash).Size     8"".(*canonicalTextHash).Size     &go.string.hdr."Sum"     4type.func([]uint8) []uint8     btype.func(*"".canonicalTextHash, []uint8) []uint8     6"".(*canonicalTextHash).Sum     6"".(*canonicalTextHash).Sum     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     ltype.func(*"".canonicalTextHash, []uint8) (int, error)     :"".(*canonicalTextHash).Write     :"".(*canonicalTextHash).Write   "runtime.gcbits.03    Rgo.string.hdr."openpgp.canonicalTextHash"                       Jgo.string."openpgp.canonicalTextHash"   Jgo.string."openpgp.canonicalTextHash" @  4openpgp.canonicalTextHash  "go.string.hdr."h"                       go.string."h"   go.string."h"   h  Vgo.string.hdr."golang.org/x/crypto/openpgp"                       Ngo.string."golang.org/x/crypto/openpgp"   Ngo.string."golang.org/x/crypto/openpgp" @  8golang.org/x/crypto/openpgp  "go.importpath."".                       Ngo.string."golang.org/x/crypto/openpgp"   "go.string.hdr."s"                       go.string."s"   go.string."s"   s  Bgo.string.hdr."canonicalTextHash"                       :go.string."canonicalTextHash"   :go.string."canonicalTextHash" 0  $canonicalTextHash  2type."".canonicalTextHash                  Xݏ                                                                                                                                                                                      0  <type..alg."".canonicalTextHash   @  "runtime.gcbits.03   P  Rgo.string.hdr."openpgp.canonicalTextHash"   p  4type.*"".canonicalTextHash    2type."".canonicalTextHash     "go.string.hdr."h"     "go.importpath."".     type.hash.Hash     "go.string.hdr."s"     "go.importpath."".     type.int   ` 2type."".canonicalTextHash     Bgo.string.hdr."canonicalTextHash"     "go.importpath."".    2type."".canonicalTextHash   Fgo.string.hdr."[]*packet.Signature"                       >go.string."[]*packet.Signature"   >go.string."[]*packet.Signature" 0  ([]*packet.Signature  htype.[]*golang.org/x/crypto/openpgp/packet.Signature                 ,Ž                                                 
0  runtime.algarray   @  "runtime.gcbits.01   P  Fgo.string.hdr."[]*packet.Signature"   p  zgo.weak.type.*[]*golang.org/x/crypto/openpgp/packet.Signature     dtype.*golang.org/x/crypto/openpgp/packet.Signature   go.typelink.[]*packet.Signature	[]*golang.org/x/crypto/openpgp/packet.Signature              htype.[]*golang.org/x/crypto/openpgp/packet.Signature   "runtime.gcbits.1d    @go.string.hdr."openpgp.Identity"                       8go.string."openpgp.Identity"   8go.string."openpgp.Identity" 0  "openpgp.Identity  (go.string.hdr."Name"                        go.string."Name"    go.string."Name"   
Name  ,go.string.hdr."UserId"                       $go.string."UserId"   $go.string."UserId"   UserId  :go.string.hdr."SelfSignature"                       2go.string."SelfSignature"   2go.string."SelfSignature"    SelfSignature  4go.string.hdr."Signatures"             
          ,go.string."Signatures"   ,go.string."Signatures"    Signatures  0go.string.hdr."Identity"                       (go.string."Identity"   (go.string."Identity"    Identity   type."".Identity    8       (       r                                                                                                                                                                                                                                                                     "0  runtime.algarray   @  "runtime.gcbits.1d   P  @go.string.hdr."openpgp.Identity"   p  "type.*"".Identity     type."".Identity     (go.string.hdr."Name"     type.string     ,go.string.hdr."UserId"     ^type.*golang.org/x/crypto/openpgp/packet.UserId     :go.string.hdr."SelfSignature"     dtype.*golang.org/x/crypto/openpgp/packet.Signature     4go.string.hdr."Signatures"     htype.[]*golang.org/x/crypto/openpgp/packet.Signature   `  type."".Identity     0go.string.hdr."Identity"     "go.importpath."".     type."".Identity   Bgo.string.hdr."*openpgp.Identity"                       :go.string."*openpgp.Identity"   :go.string."*openpgp.Identity" 0  $*openpgp.Identity  "type.*"".Identity                  w* 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  Bgo.string.hdr."*openpgp.Identity"   p  4go.weak.type.**"".Identity      type."".Identity   runtime.gcbits.      0go.string.hdr."[8]uint8"                       (go.string."[8]uint8"   (go.string."[8]uint8"    [8]uint8  type.[8]uint8                  >0                                                                0  runtime.algarray   @  runtime.gcbits.   P  0go.string.hdr."[8]uint8"   p  ,go.weak.type.*[8]uint8     type.uint8     type.[]uint8   :go.typelink.[8]uint8	[8]uint8              type.[8]uint8   0go.string.hdr."[]string"                       (go.string."[]string"   (go.string."[]string"    []string  type.[]string                 Ө
                                                 
0  runtime.algarray   @  "runtime.gcbits.01   P  0go.string.hdr."[]string"   p  ,go.weak.type.*[]string     type.string   :go.typelink.[]string	[]string              type.[]string   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             0type..hashfunc.[8]string              (type..hash.[8]string   ,type..eqfunc.[8]string              $type..eq.[8]string   &type..alg.[8]string                        0type..hashfunc.[8]string     ,type..eqfunc.[8]string   &runtime.gcbits.5555   UU 2go.string.hdr."[8]string"             	          *go.string."[8]string"   *go.string."[8]string"    [8]string  type.[8]string          x       US>                                                                0  &type..alg.[8]string   @  &runtime.gcbits.5555   P  2go.string.hdr."[8]string"   p  .go.weak.type.*[8]string     type.string     type.[]string   >go.typelink.[8]string	[8]string              type.[8]string   Fgo.string.hdr."[]*openpgp.Identity"                       >go.string."[]*openpgp.Identity"   >go.string."[]*openpgp.Identity" 0  ([]*openpgp.Identity  &type.[]*"".Identity                 ԁ                                                 
0  runtime.algarray   @  "runtime.gcbits.01   P  Fgo.string.hdr."[]*openpgp.Identity"   p  8go.weak.type.*[]*"".Identity     "type.*"".Identity   \go.typelink.[]*openpgp.Identity	[]*"".Identity              &type.[]*"".Identity    type..hashfunc64             @          ,runtime.memhash_varlen   type..eqfunc64             @          .runtime.memequal_varlen   type..alg64                         type..hashfunc64     type..eqfunc64   "runtime.gcbits.ff    Hgo.string.hdr."[8]*openpgp.Identity"                       @go.string."[8]*openpgp.Identity"   @go.string."[8]*openpgp.Identity" 0  *[8]*openpgp.Identity  (type.[8]*"".Identity   @       @       j0                                                                0  type..alg64   @  "runtime.gcbits.ff   P  Hgo.string.hdr."[8]*openpgp.Identity"   p  :go.weak.type.*[8]*"".Identity     "type.*"".Identity     &type.[]*"".Identity   `go.typelink.[8]*openpgp.Identity	[8]*"".Identity              (type.[8]*"".Identity   hgo.string.hdr."*map.bucket[string]*openpgp.Identity"             $          `go.string."*map.bucket[string]*openpgp.Identity"   `go.string."*map.bucket[string]*openpgp.Identity" P  J*map.bucket[string]*openpgp.Identity  Htype.*map.bucket[string]*"".Identity                 崞 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  hgo.string.hdr."*map.bucket[string]*openpgp.Identity"   p  Zgo.weak.type.**map.bucket[string]*"".Identity     Ftype.map.bucket[string]*"".Identity   .runtime.gcbits.aaaafe03    fgo.string.hdr."map.bucket[string]*openpgp.Identity"             #          ^go.string."map.bucket[string]*openpgp.Identity"   ^go.string."map.bucket[string]*openpgp.Identity" P  Hmap.bucket[string]*openpgp.Identity  .go.string.hdr."topbits"                       &go.string."topbits"   &go.string."topbits"   topbits  (go.string.hdr."keys"                        go.string."keys"    go.string."keys"   
keys  ,go.string.hdr."values"                       $go.string."values"   $go.string."values"   values  0go.string.hdr."overflow"                       (go.string."overflow"   (go.string."overflow"    overflow  Ftype.map.bucket[string]*"".Identity                 x|                                                                                                                                                                                                                            0  runtime.algarray   @  .runtime.gcbits.aaaafe03   P  fgo.string.hdr."map.bucket[string]*openpgp.Identity"   p  Xgo.weak.type.*map.bucket[string]*"".Identity    Ftype.map.bucket[string]*"".Identity     .go.string.hdr."topbits"     type.[8]uint8     (go.string.hdr."keys"     type.[8]string     ,go.string.hdr."values"     (type.[8]*"".Identity     0go.string.hdr."overflow"     Htype.*map.bucket[string]*"".Identity   "runtime.gcbits.2c   , `go.string.hdr."map.hdr[string]*openpgp.Identity"                        Xgo.string."map.hdr[string]*openpgp.Identity"   Xgo.string."map.hdr[string]*openpgp.Identity" P  Bmap.hdr[string]*openpgp.Identity  *go.string.hdr."count"                       "go.string."count"   "go.string."count"   count  *go.string.hdr."flags"                       "go.string."flags"   "go.string."flags"   flags  "go.string.hdr."B"                       go.string."B"   go.string."B"   B  *go.string.hdr."hash0"                       "go.string."hash0"   "go.string."hash0"   hash0  .go.string.hdr."buckets"                       &go.string."buckets"   &go.string."buckets"   buckets  4go.string.hdr."oldbuckets"             
          ,go.string."oldbuckets"   ,go.string."oldbuckets"    oldbuckets  2go.string.hdr."nevacuate"             	          *go.string."nevacuate"   *go.string."nevacuate"    nevacuate  @type.map.hdr[string]*"".Identity   0       0       P                                                                                                                                                                              	                                                                                                                                                                                                    (       *0  runtime.algarray   @  "runtime.gcbits.2c   P  `go.string.hdr."map.hdr[string]*openpgp.Identity"   p  Rgo.weak.type.*map.hdr[string]*"".Identity    @type.map.hdr[string]*"".Identity     *go.string.hdr."count"     type.int     *go.string.hdr."flags"     type.uint8     "go.string.hdr."B"     type.uint8     *go.string.hdr."hash0"     type.uint32     .go.string.hdr."buckets"     Htype.*map.bucket[string]*"".Identity     4go.string.hdr."oldbuckets"     Htype.*map.bucket[string]*"".Identity     2go.string.hdr."nevacuate"     type.uintptr     0go.string.hdr."overflow"     &type.unsafe.Pointer   Xgo.string.hdr."map[string]*openpgp.Identity"                       Pgo.string."map[string]*openpgp.Identity"   Pgo.string."map[string]*openpgp.Identity" @  :map[string]*openpgp.Identity  8type.map[string]*"".Identity                 % 5                                                                           0  runtime.algarray   @  "runtime.gcbits.01   P  Xgo.string.hdr."map[string]*openpgp.Identity"   p  Jgo.weak.type.*map[string]*"".Identity     type.string     "type.*"".Identity     Ftype.map.bucket[string]*"".Identity     @type.map.hdr[string]*"".Identity   go.typelink.map[string]*openpgp.Identity	map[string]*"".Identity              8type.map[string]*"".Identity    type..hashfunc24                       ,runtime.memhash_varlen   type..eqfunc24                       .runtime.memequal_varlen   type..alg24                         type..hashfunc24     type..eqfunc24   >go.string.hdr."*openpgp.Subkey"                       6go.string."*openpgp.Subkey"   6go.string."*openpgp.Subkey"     *openpgp.Subkey  type.*"".Subkey                  	 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  >go.string.hdr."*openpgp.Subkey"   p  0go.weak.type.**"".Subkey     type."".Subkey   "runtime.gcbits.07    <go.string.hdr."openpgp.Subkey"                       4go.string."openpgp.Subkey"   4go.string."openpgp.Subkey"    openpgp.Subkey  2go.string.hdr."PublicKey"             	          *go.string."PublicKey"   *go.string."PublicKey"    PublicKey  4go.string.hdr."PrivateKey"             
          ,go.string."PrivateKey"   ,go.string."PrivateKey"    PrivateKey  &go.string.hdr."Sig"                       go.string."Sig"   go.string."Sig"   Sig  ,go.string.hdr."Subkey"                       $go.string."Subkey"   $go.string."Subkey"   Subkey  type."".Subkey                  Y                                                                                                                                                                                                                             0  type..alg24   @  "runtime.gcbits.07   P  <go.string.hdr."openpgp.Subkey"   p  type.*"".Subkey    type."".Subkey     2go.string.hdr."PublicKey"     dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     4go.string.hdr."PrivateKey"     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     &go.string.hdr."Sig"     dtype.*golang.org/x/crypto/openpgp/packet.Signature   ` type."".Subkey     ,go.string.hdr."Subkey"     "go.importpath."".    type."".Subkey   @go.string.hdr."[]openpgp.Subkey"                       8go.string."[]openpgp.Subkey"   8go.string."[]openpgp.Subkey" 0  "[]openpgp.Subkey   type.[]"".Subkey                 Fp                                                 
0  runtime.algarray   @  "runtime.gcbits.01   P  @go.string.hdr."[]openpgp.Subkey"   p  2go.weak.type.*[]"".Subkey     type."".Subkey   Pgo.typelink.[]openpgp.Subkey	[]"".Subkey               type.[]"".Subkey   "runtime.gcbits.4f   O <go.string.hdr."openpgp.Entity"                       4go.string."openpgp.Entity"   4go.string."openpgp.Entity"    openpgp.Entity  4go.string.hdr."PrimaryKey"             
          ,go.string."PrimaryKey"   ,go.string."PrimaryKey"    PrimaryKey  4go.string.hdr."Identities"             
          ,go.string."Identities"   ,go.string."Identities"    Identities  6go.string.hdr."Revocations"                       .go.string."Revocations"   .go.string."Revocations"    Revocations  .go.string.hdr."Subkeys"                       &go.string."Subkeys"   &go.string."Subkeys"   Subkeys  ,go.string.hdr."Entity"                       $go.string."Entity"   $go.string."Entity"   Entity  type."".Entity    H       8                                                                                                                                                                                                                                                                   0                                               &0  runtime.algarray   @  "runtime.gcbits.4f   P  <go.string.hdr."openpgp.Entity"   p  type.*"".Entity    type."".Entity     4go.string.hdr."PrimaryKey"     dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     4go.string.hdr."PrivateKey"     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     4go.string.hdr."Identities"     8type.map[string]*"".Identity     6go.string.hdr."Revocations"     htype.[]*golang.org/x/crypto/openpgp/packet.Signature     .go.string.hdr."Subkeys"      type.[]"".Subkey   ` type."".Entity     ,go.string.hdr."Entity"     "go.importpath."".    type."".Entity   >go.string.hdr."*openpgp.Entity"                       6go.string."*openpgp.Entity"   6go.string."*openpgp.Entity"     *openpgp.Entity  lgo.string.hdr."func(*openpgp.Entity, io.Writer) error"             &          dgo.string."func(*openpgp.Entity, io.Writer) error"   dgo.string."func(*openpgp.Entity, io.Writer) error" P  Nfunc(*openpgp.Entity, io.Writer) error  Ltype.func(*"".Entity, io.Writer) error                 Wf 3                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  lgo.string.hdr."func(*openpgp.Entity, io.Writer) error"   p  ^go.weak.type.*func(*"".Entity, io.Writer) error    Ltype.func(*"".Entity, io.Writer) error    Ltype.func(*"".Entity, io.Writer) error     type.*"".Entity     type.io.Writer     type.error   go.typelink.func(*openpgp.Entity, io.Writer) error	func(*"".Entity, io.Writer) error              Ltype.func(*"".Entity, io.Writer) error   go.string.hdr."func(*openpgp.Entity, io.Writer, *packet.Config) error"             6          go.string."func(*openpgp.Entity, io.Writer, *packet.Config) error"   go.string."func(*openpgp.Entity, io.Writer, *packet.Config) error" p  nfunc(*openpgp.Entity, io.Writer, *packet.Config) error  type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error                 = 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*openpgp.Entity, io.Writer, *packet.Config) error"   p  go.weak.type.*func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error    type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error    type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     type.*"".Entity     type.io.Writer     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(*openpgp.Entity, io.Writer, *packet.Config) error	func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error              type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   go.string.hdr."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"             D          go.string."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"   go.string."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"   func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error  type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error                 P 3                                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"   p  go.weak.type.*func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error    type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error    type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     type.*"".Entity     type.string     type.*"".Entity     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error	func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error              type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error    type..hashfunc32                        ,runtime.memhash_varlen   type..eqfunc32                        .runtime.memequal_varlen   type..alg32                         type..hashfunc32     type..eqfunc32   8go.string.hdr."*openpgp.Key"                       0go.string."*openpgp.Key"   0go.string."*openpgp.Key"    *openpgp.Key  type.*"".Key                  ?n 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  8go.string.hdr."*openpgp.Key"   p  *go.weak.type.**"".Key     type."".Key   "runtime.gcbits.0f    6go.string.hdr."openpgp.Key"                       .go.string."openpgp.Key"   .go.string."openpgp.Key"    openpgp.Key  &go.string.hdr."Key"                       go.string."Key"   go.string."Key"   Key  type."".Key                    M,                                                                                                                                                                                                                                                                    "0  type..alg32   @  "runtime.gcbits.0f   P  6go.string.hdr."openpgp.Key"   p  type.*"".Key    type."".Key     ,go.string.hdr."Entity"     type.*"".Entity     2go.string.hdr."PublicKey"     dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     4go.string.hdr."PrivateKey"     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     :go.string.hdr."SelfSignature"     dtype.*golang.org/x/crypto/openpgp/packet.Signature   ` type."".Key     &go.string.hdr."Key"     "go.importpath."".    type."".Key   go.string.hdr."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)"             4          go.string."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)"   go.string."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)" p  jfunc(*openpgp.Entity, time.Time) (openpgp.Key, bool)  ^type.func(*"".Entity, time.Time) ("".Key, bool)                 k 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)"   p  pgo.weak.type.*func(*"".Entity, time.Time) ("".Key, bool)    ^type.func(*"".Entity, time.Time) ("".Key, bool)    ^type.func(*"".Entity, time.Time) ("".Key, bool)     type.*"".Entity     type.time.Time     type."".Key     type.bool   go.typelink.func(*openpgp.Entity, time.Time) (openpgp.Key, bool)	func(*"".Entity, time.Time) ("".Key, bool)              ^type.func(*"".Entity, time.Time) ("".Key, bool)   ngo.string.hdr."func(*openpgp.Entity) *openpgp.Identity"             '          fgo.string."func(*openpgp.Entity) *openpgp.Identity"   fgo.string."func(*openpgp.Entity) *openpgp.Identity" P  Pfunc(*openpgp.Entity) *openpgp.Identity  Dtype.func(*"".Entity) *"".Identity                 ! 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  ngo.string.hdr."func(*openpgp.Entity) *openpgp.Identity"   p  Vgo.weak.type.*func(*"".Entity) *"".Identity    Dtype.func(*"".Entity) *"".Identity    Dtype.func(*"".Entity) *"".Identity     type.*"".Entity     "type.*"".Identity   go.typelink.func(*openpgp.Entity) *openpgp.Identity	func(*"".Entity) *"".Identity              Dtype.func(*"".Entity) *"".Identity   2go.string.hdr."Serialize"             	          *go.string."Serialize"   *go.string."Serialize"    Serialize  Jgo.string.hdr."func(io.Writer) error"                       Bgo.string."func(io.Writer) error"   Bgo.string."func(io.Writer) error" 0  ,func(io.Writer) error  4type.func(io.Writer) error                 _9 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  Jgo.string.hdr."func(io.Writer) error"   p  Fgo.weak.type.*func(io.Writer) error    4type.func(io.Writer) error    4type.func(io.Writer) error     type.io.Writer     type.error   ngo.typelink.func(io.Writer) error	func(io.Writer) error              4type.func(io.Writer) error   @go.string.hdr."SerializePrivate"                       8go.string."SerializePrivate"   8go.string."SerializePrivate" 0  "SerializePrivate  jgo.string.hdr."func(io.Writer, *packet.Config) error"             %          bgo.string."func(io.Writer, *packet.Config) error"   bgo.string."func(io.Writer, *packet.Config) error" P  Lfunc(io.Writer, *packet.Config) error  type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error                 o` 3                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  jgo.string.hdr."func(io.Writer, *packet.Config) error"   p  go.weak.type.*func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error    type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error    type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     type.io.Writer     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(io.Writer, *packet.Config) error	func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error              type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   8go.string.hdr."SignIdentity"                       0go.string."SignIdentity"   0go.string."SignIdentity"    SignIdentity  go.string.hdr."func(string, *openpgp.Entity, *packet.Config) error"             3          ~go.string."func(string, *openpgp.Entity, *packet.Config) error"   ~go.string."func(string, *openpgp.Entity, *packet.Config) error" p  hfunc(string, *openpgp.Entity, *packet.Config) error  type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error                 0= 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(string, *openpgp.Entity, *packet.Config) error"   p  go.weak.type.*func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error    type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error    type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     type.string     type.*"".Entity     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(string, *openpgp.Entity, *packet.Config) error	func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error              type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   :go.string.hdr."encryptionKey"                       2go.string."encryptionKey"   2go.string."encryptionKey"    encryptionKey  fgo.string.hdr."func(time.Time) (openpgp.Key, bool)"             #          ^go.string."func(time.Time) (openpgp.Key, bool)"   ^go.string."func(time.Time) (openpgp.Key, bool)" P  Hfunc(time.Time) (openpgp.Key, bool)  Ftype.func(time.Time) ("".Key, bool)                 3I 3                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  fgo.string.hdr."func(time.Time) (openpgp.Key, bool)"   p  Xgo.weak.type.*func(time.Time) ("".Key, bool)    Ftype.func(time.Time) ("".Key, bool)    Ftype.func(time.Time) ("".Key, bool)     type.time.Time     type."".Key     type.bool   go.typelink.func(time.Time) (openpgp.Key, bool)	func(time.Time) ("".Key, bool)              Ftype.func(time.Time) ("".Key, bool)   >go.string.hdr."primaryIdentity"                       6go.string."primaryIdentity"   6go.string."primaryIdentity"     primaryIdentity  Pgo.string.hdr."func() *openpgp.Identity"                       Hgo.string."func() *openpgp.Identity"   Hgo.string."func() *openpgp.Identity" @  2func() *openpgp.Identity  0type.func() *"".Identity                 $ 3                                                                                                      0  runtime.algarray   @  "runtime.gcbits.01   P  Pgo.string.hdr."func() *openpgp.Identity"   p  Bgo.weak.type.*func() *"".Identity    0type.func() *"".Identity    0type.func() *"".Identity     "type.*"".Identity   pgo.typelink.func() *openpgp.Identity	func() *"".Identity              0type.func() *"".Identity   4go.string.hdr."signingKey"             
          ,go.string."signingKey"   ,go.string."signingKey"    signingKey  type.*"".Entity                  U㈡ 6                                                                                                                                                                                                                                                                                                                                                                                      P0  runtime.algarray   @  "runtime.gcbits.01   P  >go.string.hdr."*openpgp.Entity"   p  0go.weak.type.**"".Entity     type."".Entity   ` type.*"".Entity    type.*"".Entity     2go.string.hdr."Serialize"     4type.func(io.Writer) error     Ltype.func(*"".Entity, io.Writer) error     ,"".(*Entity).Serialize     ,"".(*Entity).Serialize     @go.string.hdr."SerializePrivate"     type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     :"".(*Entity).SerializePrivate     :"".(*Entity).SerializePrivate     8go.string.hdr."SignIdentity"     type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     2"".(*Entity).SignIdentity     2"".(*Entity).SignIdentity     :go.string.hdr."encryptionKey"     "go.importpath."".     Ftype.func(time.Time) ("".Key, bool)     ^type.func(*"".Entity, time.Time) ("".Key, bool)     4"".(*Entity).encryptionKey     4"".(*Entity).encryptionKey     >go.string.hdr."primaryIdentity"     "go.importpath."".     0type.func() *"".Identity     Dtype.func(*"".Entity) *"".Identity     8"".(*Entity).primaryIdentity     8"".(*Entity).primaryIdentity     4go.string.hdr."signingKey"     "go.importpath."".     Ftype.func(time.Time) ("".Key, bool)     ^type.func(*"".Entity, time.Time) ("".Key, bool)     ."".(*Entity).signingKey     ."".(*Entity).signingKey   Dgo.string.hdr."**openpgp.Identity"                       <go.string."**openpgp.Identity"   <go.string."**openpgp.Identity" 0  &**openpgp.Identity  $type.**"".Identity                 yqZ 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  Dgo.string.hdr."**openpgp.Identity"   p  6go.weak.type.***"".Identity     "type.*"".Identity   bgo.string.hdr."*map.hdr[string]*openpgp.Identity"             !          Zgo.string."*map.hdr[string]*openpgp.Identity"   Zgo.string."*map.hdr[string]*openpgp.Identity" P  D*map.hdr[string]*openpgp.Identity  Btype.*map.hdr[string]*"".Identity                 nu 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  bgo.string.hdr."*map.hdr[string]*openpgp.Identity"   p  Tgo.weak.type.**map.hdr[string]*"".Identity     @type.map.hdr[string]*"".Identity   bgo.string.hdr."map.iter[string]*openpgp.Identity"             !          Zgo.string."map.iter[string]*openpgp.Identity"   Zgo.string."map.iter[string]*openpgp.Identity" P  Dmap.iter[string]*openpgp.Identity  &go.string.hdr."key"                       go.string."key"   go.string."key"   key  &go.string.hdr."val"                       go.string."val"   go.string."val"   val  "go.string.hdr."t"                       go.string."t"   go.string."t"   t  (go.string.hdr."bptr"                        go.string."bptr"    go.string."bptr"   
bptr  2go.string.hdr."overflow0"             	          *go.string."overflow0"   *go.string."overflow0"    overflow0  2go.string.hdr."overflow1"             	          *go.string."overflow1"   *go.string."overflow1"    overflow1  6go.string.hdr."startBucket"                       .go.string."startBucket"   .go.string."startBucket"    startBucket  *go.string.hdr."stuff"                       "go.string."stuff"   "go.string."stuff"   stuff  ,go.string.hdr."bucket"                       $go.string."bucket"   $go.string."bucket"   bucket  6go.string.hdr."checkBucket"                       .go.string."checkBucket"   .go.string."checkBucket"    checkBucket  Btype.map.iter[string]*"".Identity   `       @       λ%                                                                                                                                                                                                                                                                                                    (                                       0                                       8                                       @                                       H                                       P                                       X       :0  runtime.algarray   @  "runtime.gcbits.ff   P  bgo.string.hdr."map.iter[string]*openpgp.Identity"   p  Tgo.weak.type.*map.iter[string]*"".Identity    Btype.map.iter[string]*"".Identity     &go.string.hdr."key"     type.*string     &go.string.hdr."val"     $type.**"".Identity     "go.string.hdr."t"     type.*uint8     "go.string.hdr."h"     Btype.*map.hdr[string]*"".Identity     .go.string.hdr."buckets"     Htype.*map.bucket[string]*"".Identity     (go.string.hdr."bptr"     Htype.*map.bucket[string]*"".Identity     2go.string.hdr."overflow0"     &type.unsafe.Pointer     2go.string.hdr."overflow1"     &type.unsafe.Pointer     6go.string.hdr."startBucket"     type.uintptr     *go.string.hdr."stuff"     type.uintptr     ,go.string.hdr."bucket"     type.uintptr     6go.string.hdr."checkBucket"     type.uintptr   Fgo.string.hdr."*openpgp.EntityList"                       >go.string."*openpgp.EntityList"   >go.string."*openpgp.EntityList" 0  (*openpgp.EntityList  .go.string.hdr."openpgp"                       &go.string."openpgp"   &go.string."openpgp"   openpgp  4go.string.hdr."EntityList"             
          ,go.string."EntityList"   ,go.string."EntityList"    EntityList  0go.string.hdr."KeysById"                       (go.string."KeysById"   (go.string."KeysById"    KeysById  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·89fe65749ce0afc971c0982226501ff0             :go.string.hdr."KeysByIdUsage"                       2go.string."KeysByIdUsage"   2go.string."KeysByIdUsage"    KeysByIdUsage  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·6432f8c6a0d23fa7bee6c5d96f21a92a             <go.string.hdr."DecryptionKeys"                       4go.string."DecryptionKeys"   4go.string."DecryptionKeys"    DecryptionKeys  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·2fccd208efe70893f9ac8d682812ae72             :go.string.hdr."[]openpgp.Key"                       2go.string."[]openpgp.Key"   2go.string."[]openpgp.Key"    []openpgp.Key  type.[]"".Key                 F                                                 
0  runtime.algarray   @  "runtime.gcbits.01   P  :go.string.hdr."[]openpgp.Key"   p  ,go.weak.type.*[]"".Key     type."".Key   Dgo.typelink.[]openpgp.Key	[]"".Key              type.[]"".Key   ngo.string.hdr."func(*openpgp.EntityList) []openpgp.Key"             '          fgo.string."func(*openpgp.EntityList) []openpgp.Key"   fgo.string."func(*openpgp.EntityList) []openpgp.Key" P  Pfunc(*openpgp.EntityList) []openpgp.Key  Dtype.func(*"".EntityList) []"".Key                 5X 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  ngo.string.hdr."func(*openpgp.EntityList) []openpgp.Key"   p  Vgo.weak.type.*func(*"".EntityList) []"".Key    Dtype.func(*"".EntityList) []"".Key    Dtype.func(*"".EntityList) []"".Key     &type.*"".EntityList     type.[]"".Key   go.typelink.func(*openpgp.EntityList) []openpgp.Key	func(*"".EntityList) []"".Key              Dtype.func(*"".EntityList) []"".Key   ~go.string.hdr."func(*openpgp.EntityList, uint64) []openpgp.Key"             /          vgo.string."func(*openpgp.EntityList, uint64) []openpgp.Key"   vgo.string."func(*openpgp.EntityList, uint64) []openpgp.Key" `  `func(*openpgp.EntityList, uint64) []openpgp.Key  Ttype.func(*"".EntityList, uint64) []"".Key                 Űȟ 3                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  ~go.string.hdr."func(*openpgp.EntityList, uint64) []openpgp.Key"   p  fgo.weak.type.*func(*"".EntityList, uint64) []"".Key    Ttype.func(*"".EntityList, uint64) []"".Key    Ttype.func(*"".EntityList, uint64) []"".Key     &type.*"".EntityList     type.uint64     type.[]"".Key   go.typelink.func(*openpgp.EntityList, uint64) []openpgp.Key	func(*"".EntityList, uint64) []"".Key              Ttype.func(*"".EntityList, uint64) []"".Key   go.string.hdr."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key"             6          go.string."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key"   go.string."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key" p  nfunc(*openpgp.EntityList, uint64, uint8) []openpgp.Key  btype.func(*"".EntityList, uint64, uint8) []"".Key                 uJ? 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key"   p  tgo.weak.type.*func(*"".EntityList, uint64, uint8) []"".Key    btype.func(*"".EntityList, uint64, uint8) []"".Key    btype.func(*"".EntityList, uint64, uint8) []"".Key     &type.*"".EntityList     type.uint64     type.uint8     type.[]"".Key   go.typelink.func(*openpgp.EntityList, uint64, uint8) []openpgp.Key	func(*"".EntityList, uint64, uint8) []"".Key              btype.func(*"".EntityList, uint64, uint8) []"".Key   Hgo.string.hdr."func() []openpgp.Key"                       @go.string."func() []openpgp.Key"   @go.string."func() []openpgp.Key" 0  *func() []openpgp.Key  (type.func() []"".Key                 · 3                                                                                                      0  runtime.algarray   @  "runtime.gcbits.01   P  Hgo.string.hdr."func() []openpgp.Key"   p  :go.weak.type.*func() []"".Key    (type.func() []"".Key    (type.func() []"".Key     type.[]"".Key   `go.typelink.func() []openpgp.Key	func() []"".Key              (type.func() []"".Key   Tgo.string.hdr."func(uint64) []openpgp.Key"                       Lgo.string."func(uint64) []openpgp.Key"   Lgo.string."func(uint64) []openpgp.Key" @  6func(uint64) []openpgp.Key  4type.func(uint64) []"".Key                 m 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  Tgo.string.hdr."func(uint64) []openpgp.Key"   p  Fgo.weak.type.*func(uint64) []"".Key    4type.func(uint64) []"".Key    4type.func(uint64) []"".Key     type.uint64     type.[]"".Key   xgo.typelink.func(uint64) []openpgp.Key	func(uint64) []"".Key              4type.func(uint64) []"".Key   bgo.string.hdr."func(uint64, uint8) []openpgp.Key"             !          Zgo.string."func(uint64, uint8) []openpgp.Key"   Zgo.string."func(uint64, uint8) []openpgp.Key" P  Dfunc(uint64, uint8) []openpgp.Key  Btype.func(uint64, uint8) []"".Key                 "GV 3                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  bgo.string.hdr."func(uint64, uint8) []openpgp.Key"   p  Tgo.weak.type.*func(uint64, uint8) []"".Key    Btype.func(uint64, uint8) []"".Key    Btype.func(uint64, uint8) []"".Key     type.uint64     type.uint8     type.[]"".Key   go.typelink.func(uint64, uint8) []openpgp.Key	func(uint64, uint8) []"".Key              Btype.func(uint64, uint8) []"".Key   &type.*"".EntityList                   6                                                                                                                                                                                                                                      ,0  runtime.algarray   @  "runtime.gcbits.01   P  Fgo.string.hdr."*openpgp.EntityList"   p  8go.weak.type.**"".EntityList     $type."".EntityList   ` &type.*"".EntityList    &type.*"".EntityList     <go.string.hdr."DecryptionKeys"     (type.func() []"".Key     Dtype.func(*"".EntityList) []"".Key     >"".(*EntityList).DecryptionKeys     >"".(*EntityList).DecryptionKeys     0go.string.hdr."KeysById"     4type.func(uint64) []"".Key     Ttype.func(*"".EntityList, uint64) []"".Key     2"".(*EntityList).KeysById     2"".(*EntityList).KeysById     :go.string.hdr."KeysByIdUsage"     Btype.func(uint64, uint8) []"".Key     btype.func(*"".EntityList, uint64, uint8) []"".Key     <"".(*EntityList).KeysByIdUsage     <"".(*EntityList).KeysByIdUsage   Dgo.string.hdr."openpgp.EntityList"                       <go.string."openpgp.EntityList"   <go.string."openpgp.EntityList" 0  &openpgp.EntityList  lgo.string.hdr."func(openpgp.EntityList) []openpgp.Key"             &          dgo.string."func(openpgp.EntityList) []openpgp.Key"   dgo.string."func(openpgp.EntityList) []openpgp.Key" P  Nfunc(openpgp.EntityList) []openpgp.Key  Btype.func("".EntityList) []"".Key                 "} 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  lgo.string.hdr."func(openpgp.EntityList) []openpgp.Key"   p  Tgo.weak.type.*func("".EntityList) []"".Key    Btype.func("".EntityList) []"".Key    Btype.func("".EntityList) []"".Key     $type."".EntityList     type.[]"".Key   go.typelink.func(openpgp.EntityList) []openpgp.Key	func("".EntityList) []"".Key              Btype.func("".EntityList) []"".Key   |go.string.hdr."func(openpgp.EntityList, uint64) []openpgp.Key"             .          tgo.string."func(openpgp.EntityList, uint64) []openpgp.Key"   tgo.string."func(openpgp.EntityList, uint64) []openpgp.Key" `  ^func(openpgp.EntityList, uint64) []openpgp.Key  Rtype.func("".EntityList, uint64) []"".Key                  3                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  |go.string.hdr."func(openpgp.EntityList, uint64) []openpgp.Key"   p  dgo.weak.type.*func("".EntityList, uint64) []"".Key    Rtype.func("".EntityList, uint64) []"".Key    Rtype.func("".EntityList, uint64) []"".Key     $type."".EntityList     type.uint64     type.[]"".Key   go.typelink.func(openpgp.EntityList, uint64) []openpgp.Key	func("".EntityList, uint64) []"".Key              Rtype.func("".EntityList, uint64) []"".Key   go.string.hdr."func(openpgp.EntityList, uint64, uint8) []openpgp.Key"             5          go.string."func(openpgp.EntityList, uint64, uint8) []openpgp.Key"   go.string."func(openpgp.EntityList, uint64, uint8) []openpgp.Key" p  lfunc(openpgp.EntityList, uint64, uint8) []openpgp.Key  `type.func("".EntityList, uint64, uint8) []"".Key                 eᒑ 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(openpgp.EntityList, uint64, uint8) []openpgp.Key"   p  rgo.weak.type.*func("".EntityList, uint64, uint8) []"".Key    `type.func("".EntityList, uint64, uint8) []"".Key    `type.func("".EntityList, uint64, uint8) []"".Key     $type."".EntityList     type.uint64     type.uint8     type.[]"".Key   go.typelink.func(openpgp.EntityList, uint64, uint8) []openpgp.Key	func("".EntityList, uint64, uint8) []"".Key              `type.func("".EntityList, uint64, uint8) []"".Key   $type."".EntityList                  G                                                                                                                                                                                                                                       00  runtime.algarray   @  "runtime.gcbits.01   P  Dgo.string.hdr."openpgp.EntityList"   p  &type.*"".EntityList     type.*"".Entity   ` $type."".EntityList     4go.string.hdr."EntityList"     "go.importpath."".    $type."".EntityList     <go.string.hdr."DecryptionKeys"     (type.func() []"".Key     Btype.func("".EntityList) []"".Key     >"".(*EntityList).DecryptionKeys     8"".EntityList.DecryptionKeys     0go.string.hdr."KeysById"     4type.func(uint64) []"".Key     Rtype.func("".EntityList, uint64) []"".Key     2"".(*EntityList).KeysById     ,"".EntityList.KeysById     :go.string.hdr."KeysByIdUsage"     Btype.func(uint64, uint8) []"".Key     `type.func("".EntityList, uint64, uint8) []"".Key     <"".(*EntityList).KeysByIdUsage     6"".EntityList.KeysByIdUsage   @go.string.hdr."**openpgp.Entity"                       8go.string."**openpgp.Entity"   8go.string."**openpgp.Entity" 0  "**openpgp.Entity   type.**"".Entity                 \f 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  @go.string.hdr."**openpgp.Entity"   p  2go.weak.type.***"".Entity     type.*"".Entity   6go.string.hdr."[]io.Reader"                       .go.string."[]io.Reader"   .go.string."[]io.Reader"    []io.Reader   type.[]io.Reader                 ~z|                                                 
0  runtime.algarray   @  "runtime.gcbits.01   P  6go.string.hdr."[]io.Reader"   p  2go.weak.type.*[]io.Reader     type.io.Reader   Fgo.typelink.[]io.Reader	[]io.Reader               type.[]io.Reader   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             6type..hashfunc.[1]io.Reader              .type..hash.[1]io.Reader   2type..eqfunc.[1]io.Reader              *type..eq.[1]io.Reader   ,type..alg.[1]io.Reader                        6type..hashfunc.[1]io.Reader     2type..eqfunc.[1]io.Reader   8go.string.hdr."[1]io.Reader"                       0go.string."[1]io.Reader"   0go.string."[1]io.Reader"    [1]io.Reader  "type.[1]io.Reader                 Rx                                                                0  ,type..alg.[1]io.Reader   @  "runtime.gcbits.03   P  8go.string.hdr."[1]io.Reader"   p  4go.weak.type.*[1]io.Reader     type.io.Reader      type.[]io.Reader   Jgo.typelink.[1]io.Reader	[1]io.Reader              "type.[1]io.Reader   :go.string.hdr."*[1]io.Reader"                       2go.string."*[1]io.Reader"   2go.string."*[1]io.Reader"    *[1]io.Reader  $type.*[1]io.Reader                 &2 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  :go.string.hdr."*[1]io.Reader"   p  6go.weak.type.**[1]io.Reader     "type.[1]io.Reader   >go.string.hdr."[]packet.Packet"                       6go.string."[]packet.Packet"   6go.string."[]packet.Packet"     []packet.Packet  `type.[]golang.org/x/crypto/openpgp/packet.Packet                 qM                                                  
0  runtime.algarray   @  "runtime.gcbits.01   P  >go.string.hdr."[]packet.Packet"   p  rgo.weak.type.*[]golang.org/x/crypto/openpgp/packet.Packet     \type.golang.org/x/crypto/openpgp/packet.Packet   go.typelink.[]packet.Packet	[]golang.org/x/crypto/openpgp/packet.Packet              `type.[]golang.org/x/crypto/openpgp/packet.Packet   Dgo.string.hdr."**packet.Signature"                       <go.string."**packet.Signature"   <go.string."**packet.Signature" 0  &**packet.Signature  ftype.**golang.org/x/crypto/openpgp/packet.Signature                 d:u 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  Dgo.string.hdr."**packet.Signature"   p  xgo.weak.type.***golang.org/x/crypto/openpgp/packet.Signature     dtype.*golang.org/x/crypto/openpgp/packet.Signature   0go.string.hdr."[]uint64"                       (go.string."[]uint64"   (go.string."[]uint64"    []uint64  type.[]uint64                 ?i                                                  
0  runtime.algarray   @  "runtime.gcbits.01   P  0go.string.hdr."[]uint64"   p  ,go.weak.type.*[]uint64     type.uint64   :go.typelink.[]uint64	[]uint64              type.[]uint64   Ngo.string.hdr."*openpgp.MessageDetails"                       Fgo.string."*openpgp.MessageDetails"   Fgo.string."*openpgp.MessageDetails" 0  0*openpgp.MessageDetails  .type.*"".MessageDetails                  N 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  Ngo.string.hdr."*openpgp.MessageDetails"   p  @go.weak.type.**"".MessageDetails     ,type."".MessageDetails   *runtime.gcbits.e2f90f    Lgo.string.hdr."openpgp.MessageDetails"                       Dgo.string."openpgp.MessageDetails"   Dgo.string."openpgp.MessageDetails" 0  .openpgp.MessageDetails  6go.string.hdr."IsEncrypted"                       .go.string."IsEncrypted"   .go.string."IsEncrypted"    IsEncrypted  Bgo.string.hdr."EncryptedToKeyIds"                       :go.string."EncryptedToKeyIds"   :go.string."EncryptedToKeyIds" 0  $EncryptedToKeyIds  Pgo.string.hdr."IsSymmetricallyEncrypted"                       Hgo.string."IsSymmetricallyEncrypted"   Hgo.string."IsSymmetricallyEncrypted" @  2IsSymmetricallyEncrypted  :go.string.hdr."DecryptedWith"                       2go.string."DecryptedWith"   2go.string."DecryptedWith"    DecryptedWith  0go.string.hdr."IsSigned"                       (go.string."IsSigned"   (go.string."IsSigned"    IsSigned  :go.string.hdr."SignedByKeyId"                       2go.string."SignedByKeyId"   2go.string."SignedByKeyId"    SignedByKeyId  0go.string.hdr."SignedBy"                       (go.string."SignedBy"   (go.string."SignedBy"    SignedBy  6go.string.hdr."LiteralData"                       .go.string."LiteralData"   .go.string."LiteralData"    LiteralData  <go.string.hdr."UnverifiedBody"                       4go.string."UnverifiedBody"   4go.string."UnverifiedBody"    UnverifiedBody  <go.string.hdr."SignatureError"                       4go.string."SignatureError"   4go.string."SignatureError"    SignatureError  2go.string.hdr."Signature"             	          *go.string."Signature"   *go.string."Signature"    Signature  2go.string.hdr."decrypted"             	          *go.string."decrypted"   *go.string."decrypted"    decrypted  <go.string.hdr."MessageDetails"                       4go.string."MessageDetails"   4go.string."MessageDetails"    MessageDetails  ,type."".MessageDetails  	  	              1                                                                                                                                                                                                                      (                                       H                                       P                                       X                                       `                                       h                                       x                                                                                                                             D0  runtime.algarray   @  *runtime.gcbits.e2f90f   P  Lgo.string.hdr."openpgp.MessageDetails"   p  .type.*"".MessageDetails    ,type."".MessageDetails     6go.string.hdr."IsEncrypted"     type.bool     Bgo.string.hdr."EncryptedToKeyIds"     type.[]uint64     Pgo.string.hdr."IsSymmetricallyEncrypted"     type.bool     :go.string.hdr."DecryptedWith"     type."".Key     0go.string.hdr."IsSigned"     type.bool     :go.string.hdr."SignedByKeyId"     type.uint64     0go.string.hdr."SignedBy"     type.*"".Key     6go.string.hdr."LiteralData"     htype.*golang.org/x/crypto/openpgp/packet.LiteralData     <go.string.hdr."UnverifiedBody"     type.io.Reader     <go.string.hdr."SignatureError"     type.error     2go.string.hdr."Signature"     dtype.*golang.org/x/crypto/openpgp/packet.Signature     2go.string.hdr."decrypted"     "go.importpath."".     $type.io.ReadCloser   ` ,type."".MessageDetails     <go.string.hdr."MessageDetails"   	  "go.importpath."".   		 ,type."".MessageDetails   ,go.string.hdr."[]bool"                       $go.string."[]bool"   $go.string."[]bool"   []bool  type.[]bool                                                                  
0  runtime.algarray   @  "runtime.gcbits.01   P  ,go.string.hdr."[]bool"   p  (go.weak.type.*[]bool     type.bool   2go.typelink.[]bool	[]bool              type.[]bool   .go.string.hdr."[8]bool"                       &go.string."[8]bool"   &go.string."[8]bool"   [8]bool  type.[8]bool                  s5                                                                0  runtime.algarray   @  runtime.gcbits.   P  .go.string.hdr."[8]bool"   p  *go.weak.type.*[8]bool     type.bool     type.[]bool   6go.typelink.[8]bool	[8]bool              type.[8]bool   Ngo.string.hdr."*map.bucket[string]bool"                       Fgo.string."*map.bucket[string]bool"   Fgo.string."*map.bucket[string]bool" 0  0*map.bucket[string]bool  8type.*map.bucket[string]bool                 [E 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  Ngo.string.hdr."*map.bucket[string]bool"   p  Jgo.weak.type.**map.bucket[string]bool     6type.map.bucket[string]bool   *runtime.gcbits.aaaa04    Lgo.string.hdr."map.bucket[string]bool"                       Dgo.string."map.bucket[string]bool"   Dgo.string."map.bucket[string]bool" 0  .map.bucket[string]bool  6type.map.bucket[string]bool                 2aB                                                                                                                                                                                                                            0  runtime.algarray   @  *runtime.gcbits.aaaa04   P  Lgo.string.hdr."map.bucket[string]bool"   p  Hgo.weak.type.*map.bucket[string]bool    6type.map.bucket[string]bool     .go.string.hdr."topbits"     type.[8]uint8     (go.string.hdr."keys"     type.[8]string     ,go.string.hdr."values"     type.[8]bool     0go.string.hdr."overflow"     8type.*map.bucket[string]bool   Fgo.string.hdr."map.hdr[string]bool"                       >go.string."map.hdr[string]bool"   >go.string."map.hdr[string]bool" 0  (map.hdr[string]bool  0type.map.hdr[string]bool   0       0       3(                                                                                                                                                                              	                                                                                                                                                                                                    (       *0  runtime.algarray   @  "runtime.gcbits.2c   P  Fgo.string.hdr."map.hdr[string]bool"   p  Bgo.weak.type.*map.hdr[string]bool    0type.map.hdr[string]bool     *go.string.hdr."count"     type.int     *go.string.hdr."flags"     type.uint8     "go.string.hdr."B"     type.uint8     *go.string.hdr."hash0"     type.uint32     .go.string.hdr."buckets"     8type.*map.bucket[string]bool     4go.string.hdr."oldbuckets"     8type.*map.bucket[string]bool     2go.string.hdr."nevacuate"     type.uintptr     0go.string.hdr."overflow"     &type.unsafe.Pointer   >go.string.hdr."map[string]bool"                       6go.string."map[string]bool"   6go.string."map[string]bool"     map[string]bool  (type.map[string]bool                  5                                                                           0  runtime.algarray   @  "runtime.gcbits.01   P  >go.string.hdr."map[string]bool"   p  :go.weak.type.*map[string]bool     type.string     type.bool     6type.map.bucket[string]bool     0type.map.hdr[string]bool   Vgo.typelink.map[string]bool	map[string]bool              (type.map[string]bool   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·1347047f6245a35b91e9a4f213167d52             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·d98f60bd8519d0c68364b2a1d83af357             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             @go.string.hdr."*openpgp.KeyRing"                       8go.string."*openpgp.KeyRing"   8go.string."*openpgp.KeyRing" 0  "*openpgp.KeyRing   type.*"".KeyRing                  $ 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  @go.string.hdr."*openpgp.KeyRing"   p  2go.weak.type.**"".KeyRing     type."".KeyRing   >go.string.hdr."openpgp.KeyRing"                       6go.string."openpgp.KeyRing"   6go.string."openpgp.KeyRing"     openpgp.KeyRing  .go.string.hdr."KeyRing"                       &go.string."KeyRing"   &go.string."KeyRing"   KeyRing  type."".KeyRing                  N                                                                                                                                                                               0  runtime.algarray   @  "runtime.gcbits.03   P  >go.string.hdr."openpgp.KeyRing"   p   type.*"".KeyRing    type."".KeyRing     <go.string.hdr."DecryptionKeys"     (type.func() []"".Key     0go.string.hdr."KeysById"     4type.func(uint64) []"".Key     :go.string.hdr."KeysByIdUsage"     Btype.func(uint64, uint8) []"".Key   ` type."".KeyRing     .go.string.hdr."KeyRing"     "go.importpath."".    type."".KeyRing   Ngo.string.hdr."*openpgp.PromptFunction"                       Fgo.string."*openpgp.PromptFunction"   Fgo.string."*openpgp.PromptFunction" 0  0*openpgp.PromptFunction  .type.*"".PromptFunction                  !g 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  Ngo.string.hdr."*openpgp.PromptFunction"   p  @go.weak.type.**"".PromptFunction     ,type."".PromptFunction   Lgo.string.hdr."openpgp.PromptFunction"                       Dgo.string."openpgp.PromptFunction"   Dgo.string."openpgp.PromptFunction" 0  .openpgp.PromptFunction  <go.string.hdr."PromptFunction"                       4go.string."PromptFunction"   4go.string."PromptFunction"    PromptFunction  ,type."".PromptFunction                  4 3                                                                                                                                                                    0  runtime.algarray   @  "runtime.gcbits.01   P  Lgo.string.hdr."openpgp.PromptFunction"   p  .type.*"".PromptFunction    ,type."".PromptFunction    ,type."".PromptFunction     type.[]"".Key     type.bool     type.[]uint8     type.error   ` ,type."".PromptFunction     <go.string.hdr."PromptFunction"     "go.importpath."".    ,type."".PromptFunction   ^go.string.hdr."[]*packet.SymmetricKeyEncrypted"                       Vgo.string."[]*packet.SymmetricKeyEncrypted"   Vgo.string."[]*packet.SymmetricKeyEncrypted" @  @[]*packet.SymmetricKeyEncrypted  type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted                 ް-                                                 
0  runtime.algarray   @  "runtime.gcbits.01   P  ^go.string.hdr."[]*packet.SymmetricKeyEncrypted"   p  go.weak.type.*[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted     |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   go.typelink.[]*packet.SymmetricKeyEncrypted	[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted              type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted    type..hashfunc40             (          ,runtime.memhash_varlen   type..eqfunc40             (          .runtime.memequal_varlen   type..alg40                         type..hashfunc40     type..eqfunc40   Pgo.string.hdr."*openpgp.keyEnvelopePair"                       Hgo.string."*openpgp.keyEnvelopePair"   Hgo.string."*openpgp.keyEnvelopePair" @  2*openpgp.keyEnvelopePair  0type.*"".keyEnvelopePair                  GR4 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  Pgo.string.hdr."*openpgp.keyEnvelopePair"   p  Bgo.weak.type.**"".keyEnvelopePair     .type."".keyEnvelopePair   "runtime.gcbits.1f    Ngo.string.hdr."openpgp.keyEnvelopePair"                       Fgo.string."openpgp.keyEnvelopePair"   Fgo.string."openpgp.keyEnvelopePair" 0  0openpgp.keyEnvelopePair  8go.string.hdr."encryptedKey"                       0go.string."encryptedKey"   0go.string."encryptedKey"    encryptedKey  >go.string.hdr."keyEnvelopePair"                       6go.string."keyEnvelopePair"   6go.string."keyEnvelopePair"     keyEnvelopePair  .type."".keyEnvelopePair    (       (                                                                                                                                                                                              0  type..alg40   @  "runtime.gcbits.1f   P  Ngo.string.hdr."openpgp.keyEnvelopePair"   p  0type.*"".keyEnvelopePair    .type."".keyEnvelopePair     &go.string.hdr."key"     "go.importpath."".     type."".Key     8go.string.hdr."encryptedKey"     "go.importpath."".     jtype.*golang.org/x/crypto/openpgp/packet.EncryptedKey   ` .type."".keyEnvelopePair     >go.string.hdr."keyEnvelopePair"     "go.importpath."".    .type."".keyEnvelopePair   Rgo.string.hdr."[]openpgp.keyEnvelopePair"                       Jgo.string."[]openpgp.keyEnvelopePair"   Jgo.string."[]openpgp.keyEnvelopePair" @  4[]openpgp.keyEnvelopePair  2type.[]"".keyEnvelopePair                 r                                                 
0  runtime.algarray   @  "runtime.gcbits.01   P  Rgo.string.hdr."[]openpgp.keyEnvelopePair"   p  Dgo.weak.type.*[]"".keyEnvelopePair     .type."".keyEnvelopePair   tgo.typelink.[]openpgp.keyEnvelopePair	[]"".keyEnvelopePair              2type.[]"".keyEnvelopePair   \go.string.hdr."**packet.SymmetricKeyEncrypted"                       Tgo.string."**packet.SymmetricKeyEncrypted"   Tgo.string."**packet.SymmetricKeyEncrypted" @  >**packet.SymmetricKeyEncrypted  ~type.**golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted                 Z 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  \go.string.hdr."**packet.SymmetricKeyEncrypted"   p  go.weak.type.***golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted     |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             Ltype..hashfunc."".signatureCheckReader              Dtype..hash."".signatureCheckReader   Htype..eqfunc."".signatureCheckReader              @type..eq."".signatureCheckReader   Btype..alg."".signatureCheckReader                        Ltype..hashfunc."".signatureCheckReader     Htype..eqfunc."".signatureCheckReader   Zgo.string.hdr."*openpgp.signatureCheckReader"                       Rgo.string."*openpgp.signatureCheckReader"   Rgo.string."*openpgp.signatureCheckReader" @  <*openpgp.signatureCheckReader  go.string.hdr."func(*openpgp.signatureCheckReader, []uint8) (int, error)"             9          go.string."func(*openpgp.signatureCheckReader, []uint8) (int, error)"   go.string."func(*openpgp.signatureCheckReader, []uint8) (int, error)"   tfunc(*openpgp.signatureCheckReader, []uint8) (int, error)  rtype.func(*"".signatureCheckReader, []uint8) (int, error)                 @. 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*openpgp.signatureCheckReader, []uint8) (int, error)"   p  go.weak.type.*func(*"".signatureCheckReader, []uint8) (int, error)    rtype.func(*"".signatureCheckReader, []uint8) (int, error)    rtype.func(*"".signatureCheckReader, []uint8) (int, error)     :type.*"".signatureCheckReader     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.signatureCheckReader, []uint8) (int, error)	func(*"".signatureCheckReader, []uint8) (int, error)              rtype.func(*"".signatureCheckReader, []uint8) (int, error)   (go.string.hdr."Read"                        go.string."Read"    go.string."Read"   
Read  :type.*"".signatureCheckReader                  :a 6                                                                                                                                      0  runtime.algarray   @  "runtime.gcbits.01   P  Zgo.string.hdr."*openpgp.signatureCheckReader"   p  Lgo.weak.type.**"".signatureCheckReader     8type."".signatureCheckReader   ` :type.*"".signatureCheckReader    :type.*"".signatureCheckReader     (go.string.hdr."Read"     >type.func([]uint8) (int, error)     rtype.func(*"".signatureCheckReader, []uint8) (int, error)     >"".(*signatureCheckReader).Read     >"".(*signatureCheckReader).Read   "runtime.gcbits.3f   ? Xgo.string.hdr."openpgp.signatureCheckReader"                       Pgo.string."openpgp.signatureCheckReader"   Pgo.string."openpgp.signatureCheckReader" @  :openpgp.signatureCheckReader  .go.string.hdr."packets"                       &go.string."packets"   &go.string."packets"   packets  6go.string.hdr."wrappedHash"                       .go.string."wrappedHash"   .go.string."wrappedHash"    wrappedHash  $go.string.hdr."md"                       go.string."md"   go.string."md"   md  Hgo.string.hdr."signatureCheckReader"                       @go.string."signatureCheckReader"   @go.string."signatureCheckReader" 0  *signatureCheckReader  8type."".signatureCheckReader    0       0       MA                                                                                                                                                                                                                     (                                               *0  Btype..alg."".signatureCheckReader   @  "runtime.gcbits.3f   P  Xgo.string.hdr."openpgp.signatureCheckReader"   p  :type.*"".signatureCheckReader    8type."".signatureCheckReader     .go.string.hdr."packets"     "go.importpath."".     ^type.*golang.org/x/crypto/openpgp/packet.Reader     "go.string.hdr."h"     "go.importpath."".     type.hash.Hash     6go.string.hdr."wrappedHash"     "go.importpath."".     type.hash.Hash     $go.string.hdr."md"     "go.importpath."".     .type.*"".MessageDetails   ` 8type."".signatureCheckReader     Hgo.string.hdr."signatureCheckReader"     "go.importpath."".    8type."".signatureCheckReader   Hgo.string.hdr."*openpgp.checkReader"                       @go.string."*openpgp.checkReader"   @go.string."*openpgp.checkReader" 0  **openpgp.checkReader  6go.string.hdr."checkReader"                       .go.string."checkReader"   .go.string."checkReader"    checkReader  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             go.string.hdr."func(*openpgp.checkReader, []uint8) (int, error)"             0          xgo.string."func(*openpgp.checkReader, []uint8) (int, error)"   xgo.string."func(*openpgp.checkReader, []uint8) (int, error)" p  bfunc(*openpgp.checkReader, []uint8) (int, error)  `type.func(*"".checkReader, []uint8) (int, error)                 V#. 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*openpgp.checkReader, []uint8) (int, error)"   p  rgo.weak.type.*func(*"".checkReader, []uint8) (int, error)    `type.func(*"".checkReader, []uint8) (int, error)    `type.func(*"".checkReader, []uint8) (int, error)     (type.*"".checkReader     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.checkReader, []uint8) (int, error)	func(*"".checkReader, []uint8) (int, error)              `type.func(*"".checkReader, []uint8) (int, error)   (type.*"".checkReader                   6                                                                                                                                      0  runtime.algarray   @  "runtime.gcbits.01   P  Hgo.string.hdr."*openpgp.checkReader"   p  :go.weak.type.**"".checkReader     &type."".checkReader   ` (type.*"".checkReader    (type.*"".checkReader     (go.string.hdr."Read"     >type.func([]uint8) (int, error)     `type.func(*"".checkReader, []uint8) (int, error)     ,"".(*checkReader).Read     ,"".(*checkReader).Read   Fgo.string.hdr."openpgp.checkReader"                       >go.string."openpgp.checkReader"   >go.string."openpgp.checkReader" 0  (openpgp.checkReader  ~go.string.hdr."func(openpgp.checkReader, []uint8) (int, error)"             /          vgo.string."func(openpgp.checkReader, []uint8) (int, error)"   vgo.string."func(openpgp.checkReader, []uint8) (int, error)" `  `func(openpgp.checkReader, []uint8) (int, error)  ^type.func("".checkReader, []uint8) (int, error)                 1f 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  ~go.string.hdr."func(openpgp.checkReader, []uint8) (int, error)"   p  pgo.weak.type.*func("".checkReader, []uint8) (int, error)    ^type.func("".checkReader, []uint8) (int, error)    ^type.func("".checkReader, []uint8) (int, error)     &type."".checkReader     type.[]uint8     type.int     type.error   go.typelink.func(openpgp.checkReader, []uint8) (int, error)	func("".checkReader, []uint8) (int, error)              ^type.func("".checkReader, []uint8) (int, error)   &type."".checkReader                  $ 9                                                                                                                                                                                            "0  runtime.algarray   @  "runtime.gcbits.01   P  Fgo.string.hdr."openpgp.checkReader"   p  (type.*"".checkReader    &type."".checkReader     $go.string.hdr."md"     "go.importpath."".     .type.*"".MessageDetails   ` &type."".checkReader     6go.string.hdr."checkReader"     "go.importpath."".    &type."".checkReader     (go.string.hdr."Read"     >type.func([]uint8) (int, error)     ^type.func("".checkReader, []uint8) (int, error)     &"".checkReader.Read     &"".checkReader.Read   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             6type..hashfunc."".FileHints              .type..hash."".FileHints   2type..eqfunc."".FileHints              *type..eq."".FileHints   ,type..alg."".FileHints                        6type..hashfunc."".FileHints     2type..eqfunc."".FileHints   "runtime.gcbits.22   " Bgo.string.hdr."openpgp.FileHints"                       :go.string."openpgp.FileHints"   :go.string."openpgp.FileHints" 0  $openpgp.FileHints  0go.string.hdr."IsBinary"                       (go.string."IsBinary"   (go.string."IsBinary"    IsBinary  0go.string.hdr."FileName"                       (go.string."FileName"   (go.string."FileName"    FileName  .go.string.hdr."ModTime"                       &go.string."ModTime"   &go.string."ModTime"   ModTime  2go.string.hdr."FileHints"             	          *go.string."FileHints"   *go.string."FileHints"    FileHints  "type."".FileHints    0       0       82                                                                                                                                                                                                                             0  ,type..alg."".FileHints   @  "runtime.gcbits.22   P  Bgo.string.hdr."openpgp.FileHints"   p  $type.*"".FileHints    "type."".FileHints     0go.string.hdr."IsBinary"     type.bool     0go.string.hdr."FileName"     type.string     .go.string.hdr."ModTime"     type.time.Time   ` "type."".FileHints     2go.string.hdr."FileHints"     "go.importpath."".    "type."".FileHints   Dgo.string.hdr."*openpgp.FileHints"                       <go.string."*openpgp.FileHints"   <go.string."*openpgp.FileHints" 0  &*openpgp.FileHints  $type.*"".FileHints                  j 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  Dgo.string.hdr."*openpgp.FileHints"   p  6go.weak.type.**"".FileHints     "type."".FileHints   Fgo.string.hdr."*openpgp.noOpCloser"                       >go.string."*openpgp.noOpCloser"   >go.string."*openpgp.noOpCloser" 0  (*openpgp.noOpCloser  4go.string.hdr."noOpCloser"             
          ,go.string."noOpCloser"   ,go.string."noOpCloser"    noOpCloser  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             *go.string.hdr."Close"                       "go.string."Close"   "go.string."Close"   Close  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             ^go.string.hdr."func(*openpgp.noOpCloser) error"                       Vgo.string."func(*openpgp.noOpCloser) error"   Vgo.string."func(*openpgp.noOpCloser) error" @  @func(*openpgp.noOpCloser) error  >type.func(*"".noOpCloser) error                 $_ 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  ^go.string.hdr."func(*openpgp.noOpCloser) error"   p  Pgo.weak.type.*func(*"".noOpCloser) error    >type.func(*"".noOpCloser) error    >type.func(*"".noOpCloser) error     &type.*"".noOpCloser     type.error   go.typelink.func(*openpgp.noOpCloser) error	func(*"".noOpCloser) error              >type.func(*"".noOpCloser) error   ~go.string.hdr."func(*openpgp.noOpCloser, []uint8) (int, error)"             /          vgo.string."func(*openpgp.noOpCloser, []uint8) (int, error)"   vgo.string."func(*openpgp.noOpCloser, []uint8) (int, error)" `  `func(*openpgp.noOpCloser, []uint8) (int, error)  ^type.func(*"".noOpCloser, []uint8) (int, error)                 6rA 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  ~go.string.hdr."func(*openpgp.noOpCloser, []uint8) (int, error)"   p  pgo.weak.type.*func(*"".noOpCloser, []uint8) (int, error)    ^type.func(*"".noOpCloser, []uint8) (int, error)    ^type.func(*"".noOpCloser, []uint8) (int, error)     &type.*"".noOpCloser     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.noOpCloser, []uint8) (int, error)	func(*"".noOpCloser, []uint8) (int, error)              ^type.func(*"".noOpCloser, []uint8) (int, error)   8go.string.hdr."func() error"                       0go.string."func() error"   0go.string."func() error"    func() error  "type.func() error                 ֵ 3                                                                                                      0  runtime.algarray   @  "runtime.gcbits.01   P  8go.string.hdr."func() error"   p  4go.weak.type.*func() error    "type.func() error    "type.func() error     type.error   Jgo.typelink.func() error	func() error              "type.func() error   &type.*"".noOpCloser                  ML 6                                                                                                                                                                                      "0  runtime.algarray   @  "runtime.gcbits.01   P  Fgo.string.hdr."*openpgp.noOpCloser"   p  8go.weak.type.**"".noOpCloser     $type."".noOpCloser   ` &type.*"".noOpCloser    &type.*"".noOpCloser     *go.string.hdr."Close"     "type.func() error     >type.func(*"".noOpCloser) error     ,"".(*noOpCloser).Close     ,"".(*noOpCloser).Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     ^type.func(*"".noOpCloser, []uint8) (int, error)     ,"".(*noOpCloser).Write     ,"".(*noOpCloser).Write   Dgo.string.hdr."openpgp.noOpCloser"                       <go.string."openpgp.noOpCloser"   <go.string."openpgp.noOpCloser" 0  &openpgp.noOpCloser  "go.string.hdr."w"                       go.string."w"   go.string."w"   w  \go.string.hdr."func(openpgp.noOpCloser) error"                       Tgo.string."func(openpgp.noOpCloser) error"   Tgo.string."func(openpgp.noOpCloser) error" @  >func(openpgp.noOpCloser) error  <type.func("".noOpCloser) error                 4Y9 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  \go.string.hdr."func(openpgp.noOpCloser) error"   p  Ngo.weak.type.*func("".noOpCloser) error    <type.func("".noOpCloser) error    <type.func("".noOpCloser) error     $type."".noOpCloser     type.error   go.typelink.func(openpgp.noOpCloser) error	func("".noOpCloser) error              <type.func("".noOpCloser) error   |go.string.hdr."func(openpgp.noOpCloser, []uint8) (int, error)"             .          tgo.string."func(openpgp.noOpCloser, []uint8) (int, error)"   tgo.string."func(openpgp.noOpCloser, []uint8) (int, error)" `  ^func(openpgp.noOpCloser, []uint8) (int, error)  \type.func("".noOpCloser, []uint8) (int, error)                 ~9 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  |go.string.hdr."func(openpgp.noOpCloser, []uint8) (int, error)"   p  ngo.weak.type.*func("".noOpCloser, []uint8) (int, error)    \type.func("".noOpCloser, []uint8) (int, error)    \type.func("".noOpCloser, []uint8) (int, error)     $type."".noOpCloser     type.[]uint8     type.int     type.error   go.typelink.func(openpgp.noOpCloser, []uint8) (int, error)	func("".noOpCloser, []uint8) (int, error)              \type.func("".noOpCloser, []uint8) (int, error)   $type."".noOpCloser                  n                                                                                                                                                                                                                                             ,0  runtime.algarray   @  "runtime.gcbits.03   P  Dgo.string.hdr."openpgp.noOpCloser"   p  &type.*"".noOpCloser    $type."".noOpCloser     "go.string.hdr."w"     "go.importpath."".     type.io.Writer   ` $type."".noOpCloser     4go.string.hdr."noOpCloser"     "go.importpath."".    $type."".noOpCloser     *go.string.hdr."Close"     "type.func() error     <type.func("".noOpCloser) error     ,"".(*noOpCloser).Close     &"".noOpCloser.Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     \type.func("".noOpCloser, []uint8) (int, error)     ,"".(*noOpCloser).Write     &"".noOpCloser.Write   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·895d0569a38a56443b84805daa09d838              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             Btype..hashfunc."".signatureWriter              :type..hash."".signatureWriter   >type..eqfunc."".signatureWriter              6type..eq."".signatureWriter   8type..alg."".signatureWriter                        Btype..hashfunc."".signatureWriter     >type..eqfunc."".signatureWriter   Pgo.string.hdr."*openpgp.signatureWriter"                       Hgo.string."*openpgp.signatureWriter"   Hgo.string."*openpgp.signatureWriter" @  2*openpgp.signatureWriter  >go.string.hdr."signatureWriter"                       6go.string."signatureWriter"   6go.string."signatureWriter"     signatureWriter  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             hgo.string.hdr."func(*openpgp.signatureWriter) error"             $          `go.string."func(*openpgp.signatureWriter) error"   `go.string."func(*openpgp.signatureWriter) error" P  Jfunc(*openpgp.signatureWriter) error  Htype.func(*"".signatureWriter) error                 / 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  hgo.string.hdr."func(*openpgp.signatureWriter) error"   p  Zgo.weak.type.*func(*"".signatureWriter) error    Htype.func(*"".signatureWriter) error    Htype.func(*"".signatureWriter) error     0type.*"".signatureWriter     type.error   go.typelink.func(*openpgp.signatureWriter) error	func(*"".signatureWriter) error              Htype.func(*"".signatureWriter) error   go.string.hdr."func(*openpgp.signatureWriter, []uint8) (int, error)"             4          go.string."func(*openpgp.signatureWriter, []uint8) (int, error)"   go.string."func(*openpgp.signatureWriter, []uint8) (int, error)" p  jfunc(*openpgp.signatureWriter, []uint8) (int, error)  htype.func(*"".signatureWriter, []uint8) (int, error)                 l 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(*openpgp.signatureWriter, []uint8) (int, error)"   p  zgo.weak.type.*func(*"".signatureWriter, []uint8) (int, error)    htype.func(*"".signatureWriter, []uint8) (int, error)    htype.func(*"".signatureWriter, []uint8) (int, error)     0type.*"".signatureWriter     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.signatureWriter, []uint8) (int, error)	func(*"".signatureWriter, []uint8) (int, error)              htype.func(*"".signatureWriter, []uint8) (int, error)   0type.*"".signatureWriter                  + 6                                                                                                                                                                                      "0  runtime.algarray   @  "runtime.gcbits.01   P  Pgo.string.hdr."*openpgp.signatureWriter"   p  Bgo.weak.type.**"".signatureWriter     .type."".signatureWriter   ` 0type.*"".signatureWriter    0type.*"".signatureWriter     *go.string.hdr."Close"     "type.func() error     Htype.func(*"".signatureWriter) error     6"".(*signatureWriter).Close     6"".(*signatureWriter).Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     htype.func(*"".signatureWriter, []uint8) (int, error)     6"".(*signatureWriter).Write     6"".(*signatureWriter).Write   &runtime.gcbits.ef01    Ngo.string.hdr."openpgp.signatureWriter"                       Fgo.string."openpgp.signatureWriter"   Fgo.string."openpgp.signatureWriter" 0  0openpgp.signatureWriter  :go.string.hdr."encryptedData"                       2go.string."encryptedData"   2go.string."encryptedData"    encryptedData  6go.string.hdr."literalData"                       .go.string."literalData"   .go.string."literalData"    literalData  0go.string.hdr."hashType"                       (go.string."hashType"   (go.string."hashType"    hashType  ,go.string.hdr."signer"                       $go.string."signer"   $go.string."signer"   signer  ,go.string.hdr."config"                       $go.string."config"   $go.string."config"   config  fgo.string.hdr."func(openpgp.signatureWriter) error"             #          ^go.string."func(openpgp.signatureWriter) error"   ^go.string."func(openpgp.signatureWriter) error" P  Hfunc(openpgp.signatureWriter) error  Ftype.func("".signatureWriter) error                 ! 3                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  fgo.string.hdr."func(openpgp.signatureWriter) error"   p  Xgo.weak.type.*func("".signatureWriter) error    Ftype.func("".signatureWriter) error    Ftype.func("".signatureWriter) error     .type."".signatureWriter     type.error   go.typelink.func(openpgp.signatureWriter) error	func("".signatureWriter) error              Ftype.func("".signatureWriter) error   go.string.hdr."func(openpgp.signatureWriter, []uint8) (int, error)"             3          ~go.string."func(openpgp.signatureWriter, []uint8) (int, error)"   ~go.string."func(openpgp.signatureWriter, []uint8) (int, error)" p  hfunc(openpgp.signatureWriter, []uint8) (int, error)  ftype.func("".signatureWriter, []uint8) (int, error)                 E 3                                                                                                                            0  runtime.algarray   @  "runtime.gcbits.01   P  go.string.hdr."func(openpgp.signatureWriter, []uint8) (int, error)"   p  xgo.weak.type.*func("".signatureWriter, []uint8) (int, error)    ftype.func("".signatureWriter, []uint8) (int, error)    ftype.func("".signatureWriter, []uint8) (int, error)     .type."".signatureWriter     type.[]uint8     type.int     type.error   go.typelink.func(openpgp.signatureWriter, []uint8) (int, error)	func("".signatureWriter, []uint8) (int, error)              ftype.func("".signatureWriter, []uint8) (int, error)   .type."".signatureWriter    H       H       դ                                                                                                                                                                                                                      (                                       8                                       @                                                                                                                                             J0  8type..alg."".signatureWriter   @  &runtime.gcbits.ef01   P  Ngo.string.hdr."openpgp.signatureWriter"   p  0type.*"".signatureWriter    .type."".signatureWriter     :go.string.hdr."encryptedData"     "go.importpath."".     &type.io.WriteCloser     6go.string.hdr."literalData"     "go.importpath."".     &type.io.WriteCloser     0go.string.hdr."hashType"     "go.importpath."".      type.crypto.Hash     "go.string.hdr."h"     "go.importpath."".     type.hash.Hash     ,go.string.hdr."signer"     "go.importpath."".     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     ,go.string.hdr."config"     "go.importpath."".     ^type.*golang.org/x/crypto/openpgp/packet.Config   ` .type."".signatureWriter     >go.string.hdr."signatureWriter"     "go.importpath."".    .type."".signatureWriter     *go.string.hdr."Close"     "type.func() error     Ftype.func("".signatureWriter) error     6"".(*signatureWriter).Close     0"".signatureWriter.Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     ftype.func("".signatureWriter, []uint8) (int, error)     6"".(*signatureWriter).Write     0"".signatureWriter.Write   Bgo.string.hdr."[]*openpgp.Entity"                       :go.string."[]*openpgp.Entity"   :go.string."[]*openpgp.Entity" 0  $[]*openpgp.Entity  "type.[]*"".Entity                 5^                                                 
0  runtime.algarray   @  "runtime.gcbits.01   P  Bgo.string.hdr."[]*openpgp.Entity"   p  4go.weak.type.*[]*"".Entity     type.*"".Entity   Tgo.typelink.[]*openpgp.Entity	[]*"".Entity              "type.[]*"".Entity   type..hashfunc3                       ,runtime.memhash_varlen   type..eqfunc3                       .runtime.memequal_varlen   type..alg3                        type..hashfunc3     type..eqfunc3   0go.string.hdr."[3]uint8"                       (go.string."[3]uint8"   (go.string."[3]uint8"    [3]uint8  type.[3]uint8                  ¹R                                                                0  type..alg3   @  runtime.gcbits.   P  0go.string.hdr."[3]uint8"   p  ,go.weak.type.*[3]uint8     type.uint8     type.[]uint8   :go.typelink.[3]uint8	[3]uint8              type.[3]uint8   2go.string.hdr."*[3]uint8"             	          *go.string."*[3]uint8"   *go.string."*[3]uint8"    *[3]uint8  type.*[3]uint8                 ifl 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  2go.string.hdr."*[3]uint8"   p  .go.weak.type.**[3]uint8     type.[3]uint8   0go.string.hdr."[4]uint8"                       (go.string."[4]uint8"   (go.string."[4]uint8"    [4]uint8  type.[4]uint8                  B                                                                0  runtime.algarray   @  runtime.gcbits.   P  0go.string.hdr."[4]uint8"   p  ,go.weak.type.*[4]uint8     type.uint8     type.[]uint8   :go.typelink.[4]uint8	[4]uint8              type.[4]uint8   2go.string.hdr."*[4]uint8"             	          *go.string."*[4]uint8"   *go.string."*[4]uint8"    *[4]uint8  type.*[4]uint8                 G 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  2go.string.hdr."*[4]uint8"   p  .go.weak.type.**[4]uint8     type.[4]uint8   2go.string.hdr."[32]uint8"             	          *go.string."[32]uint8"   *go.string."[32]uint8"    [32]uint8  type.[32]uint8                   Y                                                                 0  type..alg32   @  runtime.gcbits.   P  2go.string.hdr."[32]uint8"   p  .go.weak.type.*[32]uint8     type.uint8     type.[]uint8   >go.typelink.[32]uint8	[32]uint8              type.[32]uint8   0go.string.hdr."[2]uint8"                       (go.string."[2]uint8"   (go.string."[2]uint8"    [2]uint8  type.[2]uint8                  F                                                                0`  runtime.algarray   @  runtime.gcbits.   P  0go.string.hdr."[2]uint8"   p  ,go.weak.type.*[2]uint8     type.uint8     type.[]uint8   :go.typelink.[2]uint8	[2]uint8              type.[2]uint8   4go.string.hdr."*[8]string"             
          ,go.string."*[8]string"   ,go.string."*[8]string"    *[8]string  type.*[8]string                 o 6                                                
0  runtime.algarray   @  "runtime.gcbits.01   P  4go.string.hdr."*[8]string"   p  0go.weak.type.**[8]string     type.[8]string   (go.string.hdr."hash"                        go.string."hash"    go.string."hash"   
hash  &go.importpath.hash.                        go.string."hash"   $go.string.hdr."io"                       go.string."io"   go.string."io"   io  "go.importpath.io.                       go.string."io"   4go.string.hdr."crypto/rsa"             
          ,go.string."crypto/rsa"   ,go.string."crypto/rsa"    crypto/rsa  2go.importpath.crypto/rsa.             
          ,go.string."crypto/rsa"   ,go.string.hdr."crypto"                       $go.string."crypto"   $go.string."crypto"   crypto  *go.importpath.crypto.                       $go.string."crypto"   (go.string.hdr."time"                        go.string."time"    go.string."time"   
time  &go.importpath.time.                        go.string."time"   bgo.string.hdr."golang.org/x/crypto/openpgp/armor"             !          Zgo.string."golang.org/x/crypto/openpgp/armor"   Zgo.string."golang.org/x/crypto/openpgp/armor" P  Dgolang.org/x/crypto/openpgp/armor  `go.importpath.golang.org/x/crypto/openpgp/armor.             !          Zgo.string."golang.org/x/crypto/openpgp/armor"   dgo.string.hdr."golang.org/x/crypto/openpgp/errors"             "          \go.string."golang.org/x/crypto/openpgp/errors"   \go.string."golang.org/x/crypto/openpgp/errors" P  Fgolang.org/x/crypto/openpgp/errors  bgo.importpath.golang.org/x/crypto/openpgp/errors.             "          \go.string."golang.org/x/crypto/openpgp/errors"   .go.string.hdr."strconv"                       &go.string."strconv"   &go.string."strconv"   strconv  ,go.importpath.strconv.                       &go.string."strconv"   dgo.string.hdr."golang.org/x/crypto/openpgp/packet"             "          \go.string."golang.org/x/crypto/openpgp/packet"   \go.string."golang.org/x/crypto/openpgp/packet" P  Fgolang.org/x/crypto/openpgp/packet  bgo.importpath.golang.org/x/crypto/openpgp/packet.             "          \go.string."golang.org/x/crypto/openpgp/packet"   ^go.string.hdr."golang.org/x/crypto/openpgp/s2k"                       Vgo.string."golang.org/x/crypto/openpgp/s2k"   Vgo.string."golang.org/x/crypto/openpgp/s2k" @  @golang.org/x/crypto/openpgp/s2k  \go.importpath.golang.org/x/crypto/openpgp/s2k.                       Vgo.string."golang.org/x/crypto/openpgp/s2k"   :go.string.hdr."crypto/sha256"                       2go.string."crypto/sha256"   2go.string."crypto/sha256"    crypto/sha256  8go.importpath.crypto/sha256.                       2go.string."crypto/sha256"   Dtype..hash."".canonicalTextHash·f              >type..hash."".canonicalTextHash   @type..eq."".canonicalTextHash·f              :type..eq."".canonicalTextHash   .type..hash.[8]string·f              (type..hash.[8]string   *type..eq.[8]string·f              $type..eq.[8]string   8"".(*EntityList).KeysById·f              2"".(*EntityList).KeysById   B"".(*EntityList).KeysByIdUsage·f              <"".(*EntityList).KeysByIdUsage   D"".(*EntityList).DecryptionKeys·f              >"".(*EntityList).DecryptionKeys   4type..hash.[1]io.Reader·f              .type..hash.[1]io.Reader   0type..eq.[1]io.Reader·f              *type..eq.[1]io.Reader   8"".KeyRing.DecryptionKeys·f              2"".KeyRing.DecryptionKeys   ,"".KeyRing.KeysById·f              &"".KeyRing.KeysById   6"".KeyRing.KeysByIdUsage·f              0"".KeyRing.KeysByIdUsage   Jtype..hash."".signatureCheckReader·f              Dtype..hash."".signatureCheckReader   Ftype..eq."".signatureCheckReader·f              @type..eq."".signatureCheckReader   2"".(*checkReader).Read·f              ,"".(*checkReader).Read   4type..hash."".FileHints·f              .type..hash."".FileHints   0type..eq."".FileHints·f              *type..eq."".FileHints   2"".(*noOpCloser).Write·f              ,"".(*noOpCloser).Write   2"".(*noOpCloser).Close·f              ,"".(*noOpCloser).Close   @type..hash."".signatureWriter·f              :type..hash."".signatureWriter   <type..eq."".signatureWriter·f              6type..eq."".signatureWriter   <"".(*signatureWriter).Write·f              6"".(*signatureWriter).Write   <"".(*signatureWriter).Close·f              6"".(*signatureWriter).Close   go13ld 