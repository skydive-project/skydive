    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <title>Skydive local topology</title>
        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet"/>

        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/2.5.0/cytoscape.min.js"></script>
        <script src="https://cdn.rawgit.com/cpettitt/dagre/v0.7.4/dist/dagre.min.js"></script>
        <script src="https://cdn.rawgit.com/cytoscape/cytoscape.js-dagre/1.1.2/cytoscape-dagre.js"></script>

        <script src="http://cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.js"></script>
        <link href="http://cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.css" rel="stylesheet" type="text/css" />
        <script src="https://cdn.rawgit.com/cytoscape/cytoscape.js-qtip/2.2.5/cytoscape-qtip.js"></script>

        <style>
        body {
            padding-top: 50px;
            background-color: #fff;
        }
        #cy {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
        }
        </style>

        <script>
            var switchImg = 'https://cdn2.iconfinder.com/data/icons/windows-8-metro-style/64/switch.png';
            var portImg = 'https://cdn2.iconfinder.com/data/icons/windows-8-metro-style/64/flow_chart.png';
            var intfImg = 'https://cdn2.iconfinder.com/data/icons/windows-8-metro-style/64/wired_network.png';

            var cy;

            function getMetadatas(el) {
                if (!("Metadatas" in el))
                    return "";

                var metadatas = '';
                for (k in el["Metadatas"]) {
                    metadatas += k + ': ' + el["Metadatas"][k] + "<br/>";
                }

                return metadatas;
            }

            function updateElements(topology, elements) {
                var peering = {};
                var uuidToId = {};
                var bridges = {};
                var uuidToIntf = {};

                var hostname = topology["Host"];

                elements["nodes"].push({data: {id: hostname, label: hostname, img: 'none'}});

                // first to draw all the nodes
                for (var bridgeName in topology["OvsBridges"]) {
                    bridgeId = hostname + '-ovs-' + bridgeName;

                    bridgeBoxId = 'ovsbridgesbox_' + bridgeId;
                    elements["nodes"].push({data: {
                            id: bridgeBoxId,
                            label: "",
                            parent: hostname,
                            img: 'none'
                    }});

                    elements["nodes"].push({data: {
                        id: bridgeId,
                        label: bridgeName,
                        parent: bridgeBoxId,
                        img: switchImg
                    }});

                    ports = topology["OvsBridges"][bridgeName]["Ports"]
                    for (var portName in ports) {
                        portId = bridgeId + portName;

                        elements["nodes"].push({data: {
                            id: portId,
                            label: portName,
                            parent: bridgeBoxId,
                            img: portImg,
                            metadatas: getMetadatas(ports[portName])
                        }});

                        // bridge to port
                        elements["edges"].push({data: {
                            id: bridgeId + '->' + portId,
                            source: bridgeId,
                            target: portId,
                            style: "solid",
                            edgeWidth: 4,
                            edgeColor: "#333"
                        }});

                        intfs = ports[portName]["Interfaces"]
                        for (var intfName in intfs) {
                            intfId = portId + intfName;

                            uuid = intfs[intfName]["UUID"];
                            uuidToId[uuid] = intfId;
                            uuidToIntf[uuid] = intfs[intfName];

                            elements["nodes"].push({data: {
                                id: intfId,
                                label: intfName,
                                parent: bridgeBoxId,
                                img: intfImg,
                                metadatas: getMetadatas(intfs[intfName])
                            }});

                            // port to intf
                            elements["edges"].push({data: {
                                id: portId + '->' + intfId,
                                source: portId,
                                target: intfId,
                                style: "solid",
                                edgeWidth: 4,
                                edgeColor: "#333"
                            }});

                            // build the peering mapping for the following edges contruct
                            if ("Peer" in intfs[intfName] && intfs[intfName]["Peer"]) {
                                peerUUID = intfs[intfName]["Peer"]
                                if (!(uuid in peering) && !(peerUUID in peering))
                                    peering[uuid] = peerUUID;
                            }
                        }
                    }
                }

                for (var nsName in topology["NetNss"]) {
                    var nsId = hostname + nsName;

                    // skip netns with only one interface meaning only the loopback
                    if (Object.keys(topology["NetNss"][nsName]["Interfaces"]).length < 2) {
                        continue;
                    }

                    // if not root netns draw a box
                    var parentId = hostname;
                    if (nsName != "root") {
                        elements["nodes"].push({data: {
                            id: nsId,
                            label: nsName,
                            img: 'none',
                            parent: hostname
                        }});
                        parentId = nsId;
                    }

                    intfs = topology["NetNss"][nsName]["Interfaces"]
                    for (var intfName in intfs) {
                        intfId = nsId + intfName;
                        uuid = intfs[intfName]["UUID"];

                        img = intfImg;
                        if (intfs[intfName]["Type"] == "bridge") {
                            img = switchImg;

                            // build bridge interface mapping for the following edge contruct
                            bridge = intfs[intfName]
                            if ("Interfaces" in bridge) {
                                for (childName in bridge["Interfaces"]) {
                                    childUUID = bridge["Interfaces"][childName]["UUID"]
                                    if (!(childUUID in bridges))
                                        bridges[childUUID] = uuid;
                                }
                            }
                        }

                        elements["nodes"].push({data: {
                            id: intfId,
                            label: intfName,
                            parent: parentId,
                            img: img,
                            metadatas: getMetadatas(intfs[intfName])
                        }});

                        // if already in ovs add a dotted link since this is the same interface that is
                        // in an ovs bridge and in a netns
                        if (uuid in uuidToId) {
                            elements["edges"].push({data: {
                                id: uuid + '->' + uuid,
                                source: uuidToId[uuid],
                                target: intfId,
                                style: "dotted",
                                edgeWidth: 6,
                                edgeColor: "#000"
                            }});
                        }
                        uuidToId[uuid] = intfId;
                        uuidToIntf[uuid] = intfs[intfName];

                        // build the peering mapping for the following edges contruct
                        if ("Peer" in intfs[intfName] && intfs[intfName]["Peer"]) {
                            peerUUID = intfs[intfName]["Peer"]
                            if (!(peerUUID in peering))
                                peering[uuid] = peerUUID;
                        }
                    }
                }

                // construct edges for peering mapping
                for (var uuid in peering) {
                    sourceId = uuidToId[uuid];
                    targetId = uuidToId[peering[uuid]];
                    elements["edges"].push({data: {
                        id: sourceId + '->' + targetId,
                        source: sourceId,
                        target: targetId,
                        style: "dashed",
                        edgeWidth: 4,
                        edgeColor: "#333"
                    }});
                }

                // contruct edges for bridges mapping
                for (var uuid in bridges) {
                    if (uuidToIntf[uuid]["Type"] != "veth") {
                        sourceId = uuidToId[bridges[uuid]];
                        targetId = uuidToId[uuid];
                    } else {
                        targetId = uuidToId[bridges[uuid]];
                        sourceId = uuidToId[uuid];;
                    }

                    elements["edges"].push({data: {
                        id: sourceId + '->' + targetId,
                        source: sourceId,
                        target: targetId,
                        style: "solid",
                        edgeWidth: 4,
                        edgeColor: "#333"
                    }});
                }
            }

            function drawMetadatas(cy, elements) {
                for (i in elements["nodes"]) {

                    node = elements["nodes"][i]["data"];

                    if (!("metadatas" in node) || !node["metadatas"])
                        continue;

                    cy.$('#' + node.id).qtip({
                        content: {
                            title: 'Metadatas',
                            text: node["metadatas"]
                        },
                        style: {
                            classes: 'qtip-bootstrap'
                        }
                    });
                }
            }

            function drawTopology(data) {
                var elements = {
                    nodes: [],
                    edges: []
                };

                for (hostname in data["Topologies"])
                    updateElements(data["Topologies"][hostname], elements);

                cy = cytoscape({
                    ready: function() {
                        window.cy = this;

                        drawMetadatas(this, elements);
                    },
                    container: document.getElementById('cy'),
                    pan: { x: 100, y: 0 },
                    minZoom: 0.2,
                    maxZoom: 1,
                    zoomingEnabled: true,
                    userZoomingEnabled: true,
                    panningEnabled: true,
                    userPanningEnabled: true,
                    boxSelectionEnabled: true,
                    style: [
                        {
                            selector: 'node',
                            style: {
                                'background-color': '#fff',
                                'label': 'data(label)',
                                'shape': 'rectangle',
                                'background-image': 'data(img)',
                                'shape': 'roundrectangle',
                                'font-size': 22
                            }
                        },
                        {
                            selector: '[img!="none"]',
                            style: {
                                'width': 64,
                                'height': 64
                            }
                        },
                        {
                            selector: '$node > node',
                            css: {
                                'padding-top': '10px',
                                'padding-left': '10px',
                                'padding-bottom': '10px',
                                'padding-right': '10px',
                                'text-valign': 'top',
                                'text-halign': 'center',
                                'background-color': '#aaa',
                                'shape': 'roundrectangle'
                            }
                        },
                        {
                            selector: '[^parent]',
                            css: {
                                'padding-top': '15px',
                                'padding-left': '15px',
                                'padding-bottom': '15px',
                                'padding-right': '15px',
                                'text-valign': 'top',
                                'text-halign': 'center',
                                'background-color': '#eee',
                                'shape': 'roundrectangle'
                            }
                        },
                        {
                            selector: 'edge',
                            style: {
                                'width': 'data(edgeWidth)',
                                'line-color': 'data(edgeColor)',
                                'line-style': 'data(style)',
                                'target-arrow-color': '#333'
                            }
                        }
                    ],
                    layout: {
                        name: 'dagre'
                    },
                    elements: elements
                });
            }


            $(document).ready(function() {
                $.ajax({
                    url: '/rpc/topology',
                    data: {
                        format: 'json'
                    },
                    error: function() {
                    },
                    dataType: 'json',
                    success: function(data) {
                        drawTopology(data);
                    },
                    type: 'GET'
                });
            });
        </script>
    </head>

    <body>
        <nav class="navbar navbar-inverse navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="#">Skydive</a>
                </div>
                <div id="navbar" class="collapse navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li class="active"><a href="#">Home</a></li>
                    </ul>
                </div>
            </div>
        </nav>

        <div id="cy"/>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    </body>
    </html>
